
func To{{.Name}}(ctx context.Context, tfMap types.Map) (map[string]{{.Type}}, diag.Diagnostics) {
var diags diag.Diagnostics

if tfMap.IsNull() {
return nil, diags
}

if tfMap.IsUnknown() {
diags.Append(diag.NewErrorDiagnostic(
"Map Value Is Unknown",
`Model field "{{.Name}}" is unknown.`,
))

return nil, diags
}

mapObjects := make(map[string]types.Object)

diags.Append(tfMap.ElementsAs(ctx, &mapObjects, false)...)

if diags.HasError() {
return nil, diags
}

apiObjects := make(map[string]{{.Type}}, len(mapObjects))

for k, mapObject := range mapObjects {
if mapObject.IsNull() {
apiObjects[k] = nil

continue
}

if mapObject.IsUnknown() {
diags.Append(diag.NewErrorDiagnostic(
"Object Value Within Map Is Unknown",
`Model field "{{.Name}}" contains an object which is unknown.`,
))

return nil, diags
}

var tfModel {{.Name}}Model

d := mapObject.As(ctx, &tfModel, basetypes.ObjectAsOptions{})

diags.Append(d...)

if diags.HasError() {
return nil, diags
}

apiObjects[k] = &{{.TypeReference}}{
{{- range $field := .Fields }}
{{$field.Name}}: tfModel.{{$field.Name}}.{{$field.DefaultTo}}(),
{{- end}}
}
}

return apiObjects, diags
}

func From{{.Name}}(ctx context.Context, apiObjects map[string]{{.Type}}) (types.Map, diag.Diagnostics) {
var diags diag.Diagnostics
var tfModel {{.Name}}Model

if apiObjects == nil {
return types.MapNull(
tfModel.ObjectType(ctx),
), diags
}

tfModels := make(map[string]*{{.Name}}Model)

for k, apiObject := range apiObjects {
if apiObject == nil {
tfModels[k] = nil

continue
}

tfModels[k] = &{{.Name}}Model{
{{- range $field := .Fields }}
{{$field.Name}}: types.{{$field.DefaultFrom}}(apiObject.{{$field.Name}}),
{{- end}}
}
}

return types.MapValueFrom(ctx, tfModel.ObjectType(ctx), tfModels)
}
