// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package specified

import (
	"context"
	"example.com/apisdk"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ExampleDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"bool_attribute": schema.BoolAttribute{
				Computed: true,
			},
			"list_list_attribute": schema.ListAttribute{
				ElementType: types.ListType{
					ElemType: types.StringType,
				},
				Computed: true,
			},
			"list_map_attribute": schema.ListAttribute{
				ElementType: types.MapType{
					ElemType: types.StringType,
				},
				Computed: true,
			},
			"list_nested_attribute_assoc_ext_type": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
						"float64_attribute": schema.Float64Attribute{
							Optional: true,
							Computed: true,
						},
						"int64_attribute": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
						"number_attribute": schema.NumberAttribute{
							Optional: true,
							Computed: true,
						},
						"string_attribute": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: ListNestedAttributeAssocExtTypeType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"list_nested_attribute_one": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
					},
					CustomType: ListNestedAttributeOneType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedAttributeOneValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"list_nested_attribute_three": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"list_nested_attribute_three_list_nested_attribute_one": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"list_attribute": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
								},
								CustomType: ListNestedAttributeThreeListNestedAttributeOneType{
									ObjectType: types.ObjectType{
										AttrTypes: ListNestedAttributeThreeListNestedAttributeOneValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
					},
					CustomType: ListNestedAttributeThreeType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedAttributeThreeValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"list_nested_attribute_two": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"list_nested_attribute_two_list_nested_attribute_one": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"bool_attribute": schema.BoolAttribute{
										Computed: true,
									},
								},
								CustomType: ListNestedAttributeTwoListNestedAttributeOneType{
									ObjectType: types.ObjectType{
										AttrTypes: ListNestedAttributeTwoListNestedAttributeOneValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
					},
					CustomType: ListNestedAttributeTwoType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedAttributeTwoValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"list_object_attribute": schema.ListAttribute{
				ElementType: types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"obj_string_attr": types.StringType,
					},
				},
				Computed: true,
			},
			"list_object_object_attribute": schema.ListAttribute{
				ElementType: types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"obj_obj_attr": types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"obj_obj_string_attr": types.StringType,
							},
						},
					},
				},
				Computed: true,
			},
			"map_nested_attribute_assoc_ext_type": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
						"float64_attribute": schema.Float64Attribute{
							Optional: true,
							Computed: true,
						},
						"int64_attribute": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
						"number_attribute": schema.NumberAttribute{
							Optional: true,
							Computed: true,
						},
						"string_attribute": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: MapNestedAttributeAssocExtTypeType{
						ObjectType: types.ObjectType{
							AttrTypes: MapNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"object_attribute": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"obj_string_attr": types.StringType,
				},
				Computed: true,
			},
			"object_list_attribute": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"obj_list_attr": types.ListType{
						ElemType: types.StringType,
					},
				},
				Computed: true,
			},
			"object_list_object_attribute": schema.ObjectAttribute{
				AttributeTypes: map[string]attr.Type{
					"obj_list_attr": types.ListType{
						ElemType: types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"obj_list_obj_attr": types.StringType,
							},
						},
					},
				},
				Computed: true,
			},
			"set_nested_attribute_assoc_ext_type": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
						"float64_attribute": schema.Float64Attribute{
							Optional: true,
							Computed: true,
						},
						"int64_attribute": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
						"number_attribute": schema.NumberAttribute{
							Optional: true,
							Computed: true,
						},
						"string_attribute": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: SetNestedAttributeAssocExtTypeType{
						ObjectType: types.ObjectType{
							AttrTypes: SetNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"single_nested_attribute_assoc_ext_type": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bool_attribute": schema.BoolAttribute{
						Computed: true,
					},
					"float64_attribute": schema.Float64Attribute{
						Optional: true,
						Computed: true,
					},
					"int64_attribute": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"number_attribute": schema.NumberAttribute{
						Optional: true,
						Computed: true,
					},
					"string_attribute": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SingleNestedAttributeAssocExtTypeType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"single_nested_attribute_one": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bool_attribute": schema.BoolAttribute{
						Computed: true,
					},
				},
				CustomType: SingleNestedAttributeOneType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedAttributeOneValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"single_nested_attribute_three": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"single_nested_attribute_three_single_nested_attribute_one": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"list_attribute": schema.ListAttribute{
								ElementType: types.StringType,
								Computed:    true,
							},
						},
						CustomType: SingleNestedAttributeThreeSingleNestedAttributeOneType{
							ObjectType: types.ObjectType{
								AttrTypes: SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
				},
				CustomType: SingleNestedAttributeThreeType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedAttributeThreeValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"single_nested_attribute_two": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"single_nested_attribute_two_single_nested_attribute_one": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bool_attribute": schema.BoolAttribute{
								Computed: true,
							},
						},
						CustomType: SingleNestedAttributeTwoSingleNestedAttributeOneType{
							ObjectType: types.ObjectType{
								AttrTypes: SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
				},
				CustomType: SingleNestedAttributeTwoType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedAttributeTwoValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
		},
		Blocks: map[string]schema.Block{
			"list_nested_block_assoc_ext_type": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
						"float64_attribute": schema.Float64Attribute{
							Optional: true,
							Computed: true,
						},
						"int64_attribute": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
						"number_attribute": schema.NumberAttribute{
							Optional: true,
							Computed: true,
						},
						"string_attribute": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: ListNestedBlockAssocExtTypeType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedBlockAssocExtTypeValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"list_nested_block_one": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
					},
					CustomType: ListNestedBlockOneType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedBlockOneValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"list_nested_block_three": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"object_attribute": schema.ObjectAttribute{
							AttributeTypes: map[string]attr.Type{
								"string_attribute_type": types.StringType,
							},
							Computed: true,
						},
					},
					Blocks: map[string]schema.Block{
						"list_nested_block_three_list_nested_block_one": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"list_attribute": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
								},
								CustomType: ListNestedBlockThreeListNestedBlockOneType{
									ObjectType: types.ObjectType{
										AttrTypes: ListNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
					},
					CustomType: ListNestedBlockThreeType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedBlockThreeValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"list_nested_block_two": schema.ListNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Blocks: map[string]schema.Block{
						"list_nested_block_two_list_nested_block_one": schema.ListNestedBlock{
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"bool_attribute": schema.BoolAttribute{
										Computed: true,
									},
								},
								CustomType: ListNestedBlockTwoListNestedBlockOneType{
									ObjectType: types.ObjectType{
										AttrTypes: ListNestedBlockTwoListNestedBlockOneValue{}.AttributeTypes(ctx),
									},
								},
							},
						},
					},
					CustomType: ListNestedBlockTwoType{
						ObjectType: types.ObjectType{
							AttrTypes: ListNestedBlockTwoValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"set_nested_block_assoc_ext_type": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"bool_attribute": schema.BoolAttribute{
							Computed: true,
						},
						"float64_attribute": schema.Float64Attribute{
							Optional: true,
							Computed: true,
						},
						"int64_attribute": schema.Int64Attribute{
							Optional: true,
							Computed: true,
						},
						"number_attribute": schema.NumberAttribute{
							Optional: true,
							Computed: true,
						},
						"string_attribute": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
					},
					CustomType: SetNestedBlockAssocExtTypeType{
						ObjectType: types.ObjectType{
							AttrTypes: SetNestedBlockAssocExtTypeValue{}.AttributeTypes(ctx),
						},
					},
				},
			},
			"single_nested_block_assoc_ext_type": schema.SingleNestedBlock{
				Attributes: map[string]schema.Attribute{
					"bool_attribute": schema.BoolAttribute{
						Computed: true,
					},
					"float64_attribute": schema.Float64Attribute{
						Optional: true,
						Computed: true,
					},
					"int64_attribute": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"number_attribute": schema.NumberAttribute{
						Optional: true,
						Computed: true,
					},
					"string_attribute": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: SingleNestedBlockAssocExtTypeType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedBlockAssocExtTypeValue{}.AttributeTypes(ctx),
					},
				},
			},
			"single_nested_block_one": schema.SingleNestedBlock{
				Attributes: map[string]schema.Attribute{
					"bool_attribute": schema.BoolAttribute{
						Computed: true,
					},
				},
				CustomType: SingleNestedBlockOneType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedBlockOneValue{}.AttributeTypes(ctx),
					},
				},
			},
			"single_nested_block_three": schema.SingleNestedBlock{
				Attributes: map[string]schema.Attribute{
					"object_attribute": schema.ObjectAttribute{
						AttributeTypes: map[string]attr.Type{
							"string_attribute_type": types.StringType,
						},
						Computed: true,
					},
				},
				Blocks: map[string]schema.Block{
					"single_nested_block_three_list_nested_block_one": schema.ListNestedBlock{
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"list_attribute": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
							},
							CustomType: SingleNestedBlockThreeListNestedBlockOneType{
								ObjectType: types.ObjectType{
									AttrTypes: SingleNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
								},
							},
						},
					},
				},
				CustomType: SingleNestedBlockThreeType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedBlockThreeValue{}.AttributeTypes(ctx),
					},
				},
			},
			"single_nested_block_two": schema.SingleNestedBlock{
				Blocks: map[string]schema.Block{
					"single_nested_block_two_single_nested_block_one": schema.SingleNestedBlock{
						Attributes: map[string]schema.Attribute{
							"bool_attribute": schema.BoolAttribute{
								Computed: true,
							},
						},
						CustomType: SingleNestedBlockTwoSingleNestedBlockOneType{
							ObjectType: types.ObjectType{
								AttrTypes: SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
							},
						},
					},
				},
				CustomType: SingleNestedBlockTwoType{
					ObjectType: types.ObjectType{
						AttrTypes: SingleNestedBlockTwoValue{}.AttributeTypes(ctx),
					},
				},
			},
		},
	}
}

type ExampleModel struct {
	BoolAttribute                     types.Bool                             `tfsdk:"bool_attribute"`
	ListListAttribute                 types.List                             `tfsdk:"list_list_attribute"`
	ListMapAttribute                  types.List                             `tfsdk:"list_map_attribute"`
	ListNestedAttributeAssocExtType   types.List                             `tfsdk:"list_nested_attribute_assoc_ext_type"`
	ListNestedAttributeOne            types.List                             `tfsdk:"list_nested_attribute_one"`
	ListNestedAttributeThree          types.List                             `tfsdk:"list_nested_attribute_three"`
	ListNestedAttributeTwo            types.List                             `tfsdk:"list_nested_attribute_two"`
	ListObjectAttribute               types.List                             `tfsdk:"list_object_attribute"`
	ListObjectObjectAttribute         types.List                             `tfsdk:"list_object_object_attribute"`
	MapNestedAttributeAssocExtType    types.Map                              `tfsdk:"map_nested_attribute_assoc_ext_type"`
	ObjectAttribute                   types.Object                           `tfsdk:"object_attribute"`
	ObjectListAttribute               types.Object                           `tfsdk:"object_list_attribute"`
	ObjectListObjectAttribute         types.Object                           `tfsdk:"object_list_object_attribute"`
	SetNestedAttributeAssocExtType    types.Set                              `tfsdk:"set_nested_attribute_assoc_ext_type"`
	SingleNestedAttributeAssocExtType SingleNestedAttributeAssocExtTypeValue `tfsdk:"single_nested_attribute_assoc_ext_type"`
	SingleNestedAttributeOne          SingleNestedAttributeOneValue          `tfsdk:"single_nested_attribute_one"`
	SingleNestedAttributeThree        SingleNestedAttributeThreeValue        `tfsdk:"single_nested_attribute_three"`
	SingleNestedAttributeTwo          SingleNestedAttributeTwoValue          `tfsdk:"single_nested_attribute_two"`
	ListNestedBlockAssocExtType       types.List                             `tfsdk:"list_nested_block_assoc_ext_type"`
	ListNestedBlockOne                types.List                             `tfsdk:"list_nested_block_one"`
	ListNestedBlockThree              types.List                             `tfsdk:"list_nested_block_three"`
	ListNestedBlockTwo                types.List                             `tfsdk:"list_nested_block_two"`
	SetNestedBlockAssocExtType        types.Set                              `tfsdk:"set_nested_block_assoc_ext_type"`
	SingleNestedBlockAssocExtType     SingleNestedBlockAssocExtTypeValue     `tfsdk:"single_nested_block_assoc_ext_type"`
	SingleNestedBlockOne              SingleNestedBlockOneValue              `tfsdk:"single_nested_block_one"`
	SingleNestedBlockThree            SingleNestedBlockThreeValue            `tfsdk:"single_nested_block_three"`
	SingleNestedBlockTwo              SingleNestedBlockTwoValue              `tfsdk:"single_nested_block_two"`
}

var _ basetypes.ObjectTypable = ListNestedAttributeAssocExtTypeType{}

type ListNestedAttributeAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t ListNestedAttributeAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedAttributeAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedAttributeAssocExtTypeType) String() string {
	return "ListNestedAttributeAssocExtTypeType"
}

func (t ListNestedAttributeAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeAssocExtTypeValueNull() ListNestedAttributeAssocExtTypeValue {
	return ListNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedAttributeAssocExtTypeValueUnknown() ListNestedAttributeAssocExtTypeValue {
	return ListNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedAttributeAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a ListNestedAttributeAssocExtTypeValue value, a missing attribute value was detected. "+
					"A ListNestedAttributeAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedAttributeAssocExtTypeValue Attribute Type",
				"While creating a ListNestedAttributeAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A ListNestedAttributeAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedAttributeAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a ListNestedAttributeAssocExtTypeValue value, an extra attribute value was detected. "+
					"A ListNestedAttributeAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedAttributeAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	return ListNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedAttributeAssocExtTypeValue {
	object, diags := NewListNestedAttributeAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedAttributeAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedAttributeAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedAttributeAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedAttributeAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedAttributeAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedAttributeAssocExtTypeValueMust(ListNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedAttributeAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return ListNestedAttributeAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = ListNestedAttributeAssocExtTypeValue{}

type ListNestedAttributeAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v ListNestedAttributeAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedAttributeAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedAttributeAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedAttributeAssocExtTypeValue) String() string {
	return "ListNestedAttributeAssocExtTypeValue"
}

func (v ListNestedAttributeAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v ListNestedAttributeAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedAttributeAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v ListNestedAttributeAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return ListNestedAttributeAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedAttributeAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ListNestedAttributeOneType{}

type ListNestedAttributeOneType struct {
	basetypes.ObjectType
}

func (t ListNestedAttributeOneType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedAttributeOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedAttributeOneType) String() string {
	return "ListNestedAttributeOneType"
}

func (t ListNestedAttributeOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeOneValueNull() ListNestedAttributeOneValue {
	return ListNestedAttributeOneValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedAttributeOneValueUnknown() ListNestedAttributeOneValue {
	return ListNestedAttributeOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedAttributeOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedAttributeOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedAttributeOneValue Attribute Value",
				"While creating a ListNestedAttributeOneValue value, a missing attribute value was detected. "+
					"A ListNestedAttributeOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedAttributeOneValue Attribute Type",
				"While creating a ListNestedAttributeOneValue value, an invalid attribute value was detected. "+
					"A ListNestedAttributeOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedAttributeOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedAttributeOneValue Attribute Value",
				"While creating a ListNestedAttributeOneValue value, an extra attribute value was detected. "+
					"A ListNestedAttributeOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedAttributeOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewListNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedAttributeOneValueUnknown(), diags
	}

	return ListNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedAttributeOneValue {
	object, diags := NewListNestedAttributeOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedAttributeOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedAttributeOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedAttributeOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedAttributeOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedAttributeOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedAttributeOneValueMust(ListNestedAttributeOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedAttributeOneType) ValueType(ctx context.Context) attr.Value {
	return ListNestedAttributeOneValue{}
}

var _ basetypes.ObjectValuable = ListNestedAttributeOneValue{}

type ListNestedAttributeOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v ListNestedAttributeOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedAttributeOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedAttributeOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedAttributeOneValue) String() string {
	return "ListNestedAttributeOneValue"
}

func (v ListNestedAttributeOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v ListNestedAttributeOneValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedAttributeOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v ListNestedAttributeOneValue) Type(ctx context.Context) attr.Type {
	return ListNestedAttributeOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedAttributeOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ListNestedAttributeThreeType{}

type ListNestedAttributeThreeType struct {
	basetypes.ObjectType
}

func (t ListNestedAttributeThreeType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedAttributeThreeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedAttributeThreeType) String() string {
	return "ListNestedAttributeThreeType"
}

func (t ListNestedAttributeThreeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listNestedAttributeThreeListNestedAttributeOneAttribute, ok := attributes["list_nested_attribute_three_list_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_attribute_three_list_nested_attribute_one is missing from object`)

		return nil, diags
	}

	listNestedAttributeThreeListNestedAttributeOneVal, ok := listNestedAttributeThreeListNestedAttributeOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_attribute_three_list_nested_attribute_one expected to be basetypes.ListValue, was: %T`, listNestedAttributeThreeListNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedAttributeThreeValue{
		ListNestedAttributeThreeListNestedAttributeOne: listNestedAttributeThreeListNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeThreeValueNull() ListNestedAttributeThreeValue {
	return ListNestedAttributeThreeValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedAttributeThreeValueUnknown() ListNestedAttributeThreeValue {
	return ListNestedAttributeThreeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedAttributeThreeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedAttributeThreeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedAttributeThreeValue Attribute Value",
				"While creating a ListNestedAttributeThreeValue value, a missing attribute value was detected. "+
					"A ListNestedAttributeThreeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeThreeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedAttributeThreeValue Attribute Type",
				"While creating a ListNestedAttributeThreeValue value, an invalid attribute value was detected. "+
					"A ListNestedAttributeThreeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeThreeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedAttributeThreeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedAttributeThreeValue Attribute Value",
				"While creating a ListNestedAttributeThreeValue value, an extra attribute value was detected. "+
					"A ListNestedAttributeThreeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedAttributeThreeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedAttributeThreeValueUnknown(), diags
	}

	listNestedAttributeThreeListNestedAttributeOneAttribute, ok := attributes["list_nested_attribute_three_list_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_attribute_three_list_nested_attribute_one is missing from object`)

		return NewListNestedAttributeThreeValueUnknown(), diags
	}

	listNestedAttributeThreeListNestedAttributeOneVal, ok := listNestedAttributeThreeListNestedAttributeOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_attribute_three_list_nested_attribute_one expected to be basetypes.ListValue, was: %T`, listNestedAttributeThreeListNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return NewListNestedAttributeThreeValueUnknown(), diags
	}

	return ListNestedAttributeThreeValue{
		ListNestedAttributeThreeListNestedAttributeOne: listNestedAttributeThreeListNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeThreeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedAttributeThreeValue {
	object, diags := NewListNestedAttributeThreeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedAttributeThreeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedAttributeThreeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedAttributeThreeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedAttributeThreeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedAttributeThreeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedAttributeThreeValueMust(ListNestedAttributeThreeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedAttributeThreeType) ValueType(ctx context.Context) attr.Value {
	return ListNestedAttributeThreeValue{}
}

var _ basetypes.ObjectValuable = ListNestedAttributeThreeValue{}

type ListNestedAttributeThreeValue struct {
	ListNestedAttributeThreeListNestedAttributeOne basetypes.ListValue `tfsdk:"list_nested_attribute_three_list_nested_attribute_one"`
	state                                          attr.ValueState
}

func (v ListNestedAttributeThreeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_nested_attribute_three_list_nested_attribute_one"] = basetypes.ListType{
		ElemType: ListNestedAttributeThreeListNestedAttributeOneValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListNestedAttributeThreeListNestedAttributeOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_nested_attribute_three_list_nested_attribute_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedAttributeThreeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedAttributeThreeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedAttributeThreeValue) String() string {
	return "ListNestedAttributeThreeValue"
}

func (v ListNestedAttributeThreeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listNestedAttributeThreeListNestedAttributeOne := types.ListValueMust(
		ListNestedAttributeThreeListNestedAttributeOneType{
			basetypes.ObjectType{
				AttrTypes: ListNestedAttributeThreeListNestedAttributeOneValue{}.AttributeTypes(ctx),
			},
		},
		v.ListNestedAttributeThreeListNestedAttributeOne.Elements(),
	)

	if v.ListNestedAttributeThreeListNestedAttributeOne.IsNull() {
		listNestedAttributeThreeListNestedAttributeOne = types.ListNull(
			ListNestedAttributeThreeListNestedAttributeOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedAttributeThreeListNestedAttributeOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ListNestedAttributeThreeListNestedAttributeOne.IsUnknown() {
		listNestedAttributeThreeListNestedAttributeOne = types.ListUnknown(
			ListNestedAttributeThreeListNestedAttributeOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedAttributeThreeListNestedAttributeOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_nested_attribute_three_list_nested_attribute_one": basetypes.ListType{
				ElemType: ListNestedAttributeThreeListNestedAttributeOneValue{}.Type(ctx),
			},
		},
		map[string]attr.Value{
			"list_nested_attribute_three_list_nested_attribute_one": listNestedAttributeThreeListNestedAttributeOne,
		})

	return objVal, diags
}

func (v ListNestedAttributeThreeValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedAttributeThreeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListNestedAttributeThreeListNestedAttributeOne.Equal(other.ListNestedAttributeThreeListNestedAttributeOne) {
		return false
	}

	return true
}

func (v ListNestedAttributeThreeValue) Type(ctx context.Context) attr.Type {
	return ListNestedAttributeThreeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedAttributeThreeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_nested_attribute_three_list_nested_attribute_one": basetypes.ListType{
			ElemType: ListNestedAttributeThreeListNestedAttributeOneValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ListNestedAttributeThreeListNestedAttributeOneType{}

type ListNestedAttributeThreeListNestedAttributeOneType struct {
	basetypes.ObjectType
}

func (t ListNestedAttributeThreeListNestedAttributeOneType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedAttributeThreeListNestedAttributeOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedAttributeThreeListNestedAttributeOneType) String() string {
	return "ListNestedAttributeThreeListNestedAttributeOneType"
}

func (t ListNestedAttributeThreeListNestedAttributeOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return nil, diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedAttributeThreeListNestedAttributeOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeThreeListNestedAttributeOneValueNull() ListNestedAttributeThreeListNestedAttributeOneValue {
	return ListNestedAttributeThreeListNestedAttributeOneValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedAttributeThreeListNestedAttributeOneValueUnknown() ListNestedAttributeThreeListNestedAttributeOneValue {
	return ListNestedAttributeThreeListNestedAttributeOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedAttributeThreeListNestedAttributeOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedAttributeThreeListNestedAttributeOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedAttributeThreeListNestedAttributeOneValue Attribute Value",
				"While creating a ListNestedAttributeThreeListNestedAttributeOneValue value, a missing attribute value was detected. "+
					"A ListNestedAttributeThreeListNestedAttributeOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeThreeListNestedAttributeOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedAttributeThreeListNestedAttributeOneValue Attribute Type",
				"While creating a ListNestedAttributeThreeListNestedAttributeOneValue value, an invalid attribute value was detected. "+
					"A ListNestedAttributeThreeListNestedAttributeOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeThreeListNestedAttributeOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedAttributeThreeListNestedAttributeOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedAttributeThreeListNestedAttributeOneValue Attribute Value",
				"While creating a ListNestedAttributeThreeListNestedAttributeOneValue value, an extra attribute value was detected. "+
					"A ListNestedAttributeThreeListNestedAttributeOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedAttributeThreeListNestedAttributeOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedAttributeThreeListNestedAttributeOneValueUnknown(), diags
	}

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return NewListNestedAttributeThreeListNestedAttributeOneValueUnknown(), diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedAttributeThreeListNestedAttributeOneValueUnknown(), diags
	}

	return ListNestedAttributeThreeListNestedAttributeOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeThreeListNestedAttributeOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedAttributeThreeListNestedAttributeOneValue {
	object, diags := NewListNestedAttributeThreeListNestedAttributeOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedAttributeThreeListNestedAttributeOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedAttributeThreeListNestedAttributeOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedAttributeThreeListNestedAttributeOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedAttributeThreeListNestedAttributeOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedAttributeThreeListNestedAttributeOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedAttributeThreeListNestedAttributeOneValueMust(ListNestedAttributeThreeListNestedAttributeOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedAttributeThreeListNestedAttributeOneType) ValueType(ctx context.Context) attr.Value {
	return ListNestedAttributeThreeListNestedAttributeOneValue{}
}

var _ basetypes.ObjectValuable = ListNestedAttributeThreeListNestedAttributeOneValue{}

type ListNestedAttributeThreeListNestedAttributeOneValue struct {
	ListAttribute basetypes.ListValue `tfsdk:"list_attribute"`
	state         attr.ValueState
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_attribute"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) String() string {
	return "ListNestedAttributeThreeListNestedAttributeOneValue"
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listAttributeVal, d := types.ListValue(types.StringType, v.ListAttribute.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"list_attribute": listAttributeVal,
		})

	return objVal, diags
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedAttributeThreeListNestedAttributeOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListAttribute.Equal(other.ListAttribute) {
		return false
	}

	return true
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) Type(ctx context.Context) attr.Type {
	return ListNestedAttributeThreeListNestedAttributeOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedAttributeThreeListNestedAttributeOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_attribute": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ListNestedAttributeTwoType{}

type ListNestedAttributeTwoType struct {
	basetypes.ObjectType
}

func (t ListNestedAttributeTwoType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedAttributeTwoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedAttributeTwoType) String() string {
	return "ListNestedAttributeTwoType"
}

func (t ListNestedAttributeTwoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listNestedAttributeTwoListNestedAttributeOneAttribute, ok := attributes["list_nested_attribute_two_list_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_attribute_two_list_nested_attribute_one is missing from object`)

		return nil, diags
	}

	listNestedAttributeTwoListNestedAttributeOneVal, ok := listNestedAttributeTwoListNestedAttributeOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_attribute_two_list_nested_attribute_one expected to be basetypes.ListValue, was: %T`, listNestedAttributeTwoListNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedAttributeTwoValue{
		ListNestedAttributeTwoListNestedAttributeOne: listNestedAttributeTwoListNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeTwoValueNull() ListNestedAttributeTwoValue {
	return ListNestedAttributeTwoValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedAttributeTwoValueUnknown() ListNestedAttributeTwoValue {
	return ListNestedAttributeTwoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedAttributeTwoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedAttributeTwoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedAttributeTwoValue Attribute Value",
				"While creating a ListNestedAttributeTwoValue value, a missing attribute value was detected. "+
					"A ListNestedAttributeTwoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeTwoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedAttributeTwoValue Attribute Type",
				"While creating a ListNestedAttributeTwoValue value, an invalid attribute value was detected. "+
					"A ListNestedAttributeTwoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeTwoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedAttributeTwoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedAttributeTwoValue Attribute Value",
				"While creating a ListNestedAttributeTwoValue value, an extra attribute value was detected. "+
					"A ListNestedAttributeTwoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedAttributeTwoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedAttributeTwoValueUnknown(), diags
	}

	listNestedAttributeTwoListNestedAttributeOneAttribute, ok := attributes["list_nested_attribute_two_list_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_attribute_two_list_nested_attribute_one is missing from object`)

		return NewListNestedAttributeTwoValueUnknown(), diags
	}

	listNestedAttributeTwoListNestedAttributeOneVal, ok := listNestedAttributeTwoListNestedAttributeOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_attribute_two_list_nested_attribute_one expected to be basetypes.ListValue, was: %T`, listNestedAttributeTwoListNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return NewListNestedAttributeTwoValueUnknown(), diags
	}

	return ListNestedAttributeTwoValue{
		ListNestedAttributeTwoListNestedAttributeOne: listNestedAttributeTwoListNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeTwoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedAttributeTwoValue {
	object, diags := NewListNestedAttributeTwoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedAttributeTwoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedAttributeTwoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedAttributeTwoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedAttributeTwoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedAttributeTwoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedAttributeTwoValueMust(ListNestedAttributeTwoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedAttributeTwoType) ValueType(ctx context.Context) attr.Value {
	return ListNestedAttributeTwoValue{}
}

var _ basetypes.ObjectValuable = ListNestedAttributeTwoValue{}

type ListNestedAttributeTwoValue struct {
	ListNestedAttributeTwoListNestedAttributeOne basetypes.ListValue `tfsdk:"list_nested_attribute_two_list_nested_attribute_one"`
	state                                        attr.ValueState
}

func (v ListNestedAttributeTwoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_nested_attribute_two_list_nested_attribute_one"] = basetypes.ListType{
		ElemType: ListNestedAttributeTwoListNestedAttributeOneValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListNestedAttributeTwoListNestedAttributeOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_nested_attribute_two_list_nested_attribute_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedAttributeTwoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedAttributeTwoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedAttributeTwoValue) String() string {
	return "ListNestedAttributeTwoValue"
}

func (v ListNestedAttributeTwoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listNestedAttributeTwoListNestedAttributeOne := types.ListValueMust(
		ListNestedAttributeTwoListNestedAttributeOneType{
			basetypes.ObjectType{
				AttrTypes: ListNestedAttributeTwoListNestedAttributeOneValue{}.AttributeTypes(ctx),
			},
		},
		v.ListNestedAttributeTwoListNestedAttributeOne.Elements(),
	)

	if v.ListNestedAttributeTwoListNestedAttributeOne.IsNull() {
		listNestedAttributeTwoListNestedAttributeOne = types.ListNull(
			ListNestedAttributeTwoListNestedAttributeOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedAttributeTwoListNestedAttributeOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ListNestedAttributeTwoListNestedAttributeOne.IsUnknown() {
		listNestedAttributeTwoListNestedAttributeOne = types.ListUnknown(
			ListNestedAttributeTwoListNestedAttributeOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedAttributeTwoListNestedAttributeOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_nested_attribute_two_list_nested_attribute_one": basetypes.ListType{
				ElemType: ListNestedAttributeTwoListNestedAttributeOneValue{}.Type(ctx),
			},
		},
		map[string]attr.Value{
			"list_nested_attribute_two_list_nested_attribute_one": listNestedAttributeTwoListNestedAttributeOne,
		})

	return objVal, diags
}

func (v ListNestedAttributeTwoValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedAttributeTwoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListNestedAttributeTwoListNestedAttributeOne.Equal(other.ListNestedAttributeTwoListNestedAttributeOne) {
		return false
	}

	return true
}

func (v ListNestedAttributeTwoValue) Type(ctx context.Context) attr.Type {
	return ListNestedAttributeTwoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedAttributeTwoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_nested_attribute_two_list_nested_attribute_one": basetypes.ListType{
			ElemType: ListNestedAttributeTwoListNestedAttributeOneValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ListNestedAttributeTwoListNestedAttributeOneType{}

type ListNestedAttributeTwoListNestedAttributeOneType struct {
	basetypes.ObjectType
}

func (t ListNestedAttributeTwoListNestedAttributeOneType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedAttributeTwoListNestedAttributeOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedAttributeTwoListNestedAttributeOneType) String() string {
	return "ListNestedAttributeTwoListNestedAttributeOneType"
}

func (t ListNestedAttributeTwoListNestedAttributeOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedAttributeTwoListNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeTwoListNestedAttributeOneValueNull() ListNestedAttributeTwoListNestedAttributeOneValue {
	return ListNestedAttributeTwoListNestedAttributeOneValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedAttributeTwoListNestedAttributeOneValueUnknown() ListNestedAttributeTwoListNestedAttributeOneValue {
	return ListNestedAttributeTwoListNestedAttributeOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedAttributeTwoListNestedAttributeOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedAttributeTwoListNestedAttributeOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedAttributeTwoListNestedAttributeOneValue Attribute Value",
				"While creating a ListNestedAttributeTwoListNestedAttributeOneValue value, a missing attribute value was detected. "+
					"A ListNestedAttributeTwoListNestedAttributeOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeTwoListNestedAttributeOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedAttributeTwoListNestedAttributeOneValue Attribute Type",
				"While creating a ListNestedAttributeTwoListNestedAttributeOneValue value, an invalid attribute value was detected. "+
					"A ListNestedAttributeTwoListNestedAttributeOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedAttributeTwoListNestedAttributeOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedAttributeTwoListNestedAttributeOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedAttributeTwoListNestedAttributeOneValue Attribute Value",
				"While creating a ListNestedAttributeTwoListNestedAttributeOneValue value, an extra attribute value was detected. "+
					"A ListNestedAttributeTwoListNestedAttributeOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedAttributeTwoListNestedAttributeOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedAttributeTwoListNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewListNestedAttributeTwoListNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedAttributeTwoListNestedAttributeOneValueUnknown(), diags
	}

	return ListNestedAttributeTwoListNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedAttributeTwoListNestedAttributeOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedAttributeTwoListNestedAttributeOneValue {
	object, diags := NewListNestedAttributeTwoListNestedAttributeOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedAttributeTwoListNestedAttributeOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedAttributeTwoListNestedAttributeOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedAttributeTwoListNestedAttributeOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedAttributeTwoListNestedAttributeOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedAttributeTwoListNestedAttributeOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedAttributeTwoListNestedAttributeOneValueMust(ListNestedAttributeTwoListNestedAttributeOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedAttributeTwoListNestedAttributeOneType) ValueType(ctx context.Context) attr.Value {
	return ListNestedAttributeTwoListNestedAttributeOneValue{}
}

var _ basetypes.ObjectValuable = ListNestedAttributeTwoListNestedAttributeOneValue{}

type ListNestedAttributeTwoListNestedAttributeOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) String() string {
	return "ListNestedAttributeTwoListNestedAttributeOneValue"
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedAttributeTwoListNestedAttributeOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) Type(ctx context.Context) attr.Type {
	return ListNestedAttributeTwoListNestedAttributeOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedAttributeTwoListNestedAttributeOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MapNestedAttributeAssocExtTypeType{}

type MapNestedAttributeAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t MapNestedAttributeAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(MapNestedAttributeAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MapNestedAttributeAssocExtTypeType) String() string {
	return "MapNestedAttributeAssocExtTypeType"
}

func (t MapNestedAttributeAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MapNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMapNestedAttributeAssocExtTypeValueNull() MapNestedAttributeAssocExtTypeValue {
	return MapNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewMapNestedAttributeAssocExtTypeValueUnknown() MapNestedAttributeAssocExtTypeValue {
	return MapNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMapNestedAttributeAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MapNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MapNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a MapNestedAttributeAssocExtTypeValue value, a missing attribute value was detected. "+
					"A MapNestedAttributeAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MapNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MapNestedAttributeAssocExtTypeValue Attribute Type",
				"While creating a MapNestedAttributeAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A MapNestedAttributeAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MapNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MapNestedAttributeAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MapNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a MapNestedAttributeAssocExtTypeValue value, an extra attribute value was detected. "+
					"A MapNestedAttributeAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MapNestedAttributeAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewMapNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	return MapNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMapNestedAttributeAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MapNestedAttributeAssocExtTypeValue {
	object, diags := NewMapNestedAttributeAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMapNestedAttributeAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MapNestedAttributeAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMapNestedAttributeAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMapNestedAttributeAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMapNestedAttributeAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMapNestedAttributeAssocExtTypeValueMust(MapNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MapNestedAttributeAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return MapNestedAttributeAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = MapNestedAttributeAssocExtTypeValue{}

type MapNestedAttributeAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v MapNestedAttributeAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MapNestedAttributeAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MapNestedAttributeAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MapNestedAttributeAssocExtTypeValue) String() string {
	return "MapNestedAttributeAssocExtTypeValue"
}

func (v MapNestedAttributeAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v MapNestedAttributeAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(MapNestedAttributeAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v MapNestedAttributeAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return MapNestedAttributeAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MapNestedAttributeAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SetNestedAttributeAssocExtTypeType{}

type SetNestedAttributeAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t SetNestedAttributeAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(SetNestedAttributeAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SetNestedAttributeAssocExtTypeType) String() string {
	return "SetNestedAttributeAssocExtTypeType"
}

func (t SetNestedAttributeAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SetNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSetNestedAttributeAssocExtTypeValueNull() SetNestedAttributeAssocExtTypeValue {
	return SetNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewSetNestedAttributeAssocExtTypeValueUnknown() SetNestedAttributeAssocExtTypeValue {
	return SetNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSetNestedAttributeAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SetNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SetNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a SetNestedAttributeAssocExtTypeValue value, a missing attribute value was detected. "+
					"A SetNestedAttributeAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SetNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SetNestedAttributeAssocExtTypeValue Attribute Type",
				"While creating a SetNestedAttributeAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A SetNestedAttributeAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SetNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SetNestedAttributeAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SetNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a SetNestedAttributeAssocExtTypeValue value, an extra attribute value was detected. "+
					"A SetNestedAttributeAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SetNestedAttributeAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewSetNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	return SetNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSetNestedAttributeAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SetNestedAttributeAssocExtTypeValue {
	object, diags := NewSetNestedAttributeAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSetNestedAttributeAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SetNestedAttributeAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSetNestedAttributeAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSetNestedAttributeAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSetNestedAttributeAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSetNestedAttributeAssocExtTypeValueMust(SetNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SetNestedAttributeAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return SetNestedAttributeAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = SetNestedAttributeAssocExtTypeValue{}

type SetNestedAttributeAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v SetNestedAttributeAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SetNestedAttributeAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SetNestedAttributeAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SetNestedAttributeAssocExtTypeValue) String() string {
	return "SetNestedAttributeAssocExtTypeValue"
}

func (v SetNestedAttributeAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v SetNestedAttributeAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(SetNestedAttributeAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v SetNestedAttributeAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return SetNestedAttributeAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SetNestedAttributeAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SingleNestedAttributeAssocExtTypeType{}

type SingleNestedAttributeAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t SingleNestedAttributeAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedAttributeAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedAttributeAssocExtTypeType) String() string {
	return "SingleNestedAttributeAssocExtTypeType"
}

func (t SingleNestedAttributeAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeAssocExtTypeValueNull() SingleNestedAttributeAssocExtTypeValue {
	return SingleNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedAttributeAssocExtTypeValueUnknown() SingleNestedAttributeAssocExtTypeValue {
	return SingleNestedAttributeAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedAttributeAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a SingleNestedAttributeAssocExtTypeValue value, a missing attribute value was detected. "+
					"A SingleNestedAttributeAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedAttributeAssocExtTypeValue Attribute Type",
				"While creating a SingleNestedAttributeAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A SingleNestedAttributeAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedAttributeAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedAttributeAssocExtTypeValue Attribute Value",
				"While creating a SingleNestedAttributeAssocExtTypeValue value, an extra attribute value was detected. "+
					"A SingleNestedAttributeAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedAttributeAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), diags
	}

	return SingleNestedAttributeAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedAttributeAssocExtTypeValue {
	object, diags := NewSingleNestedAttributeAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedAttributeAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedAttributeAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedAttributeAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedAttributeAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedAttributeAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedAttributeAssocExtTypeValueMust(SingleNestedAttributeAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedAttributeAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedAttributeAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = SingleNestedAttributeAssocExtTypeValue{}

type SingleNestedAttributeAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v SingleNestedAttributeAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedAttributeAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedAttributeAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedAttributeAssocExtTypeValue) String() string {
	return "SingleNestedAttributeAssocExtTypeValue"
}

func (v SingleNestedAttributeAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v SingleNestedAttributeAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedAttributeAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v SingleNestedAttributeAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return SingleNestedAttributeAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedAttributeAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SingleNestedAttributeOneType{}

type SingleNestedAttributeOneType struct {
	basetypes.ObjectType
}

func (t SingleNestedAttributeOneType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedAttributeOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedAttributeOneType) String() string {
	return "SingleNestedAttributeOneType"
}

func (t SingleNestedAttributeOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeOneValueNull() SingleNestedAttributeOneValue {
	return SingleNestedAttributeOneValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedAttributeOneValueUnknown() SingleNestedAttributeOneValue {
	return SingleNestedAttributeOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedAttributeOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedAttributeOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedAttributeOneValue Attribute Value",
				"While creating a SingleNestedAttributeOneValue value, a missing attribute value was detected. "+
					"A SingleNestedAttributeOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedAttributeOneValue Attribute Type",
				"While creating a SingleNestedAttributeOneValue value, an invalid attribute value was detected. "+
					"A SingleNestedAttributeOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedAttributeOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedAttributeOneValue Attribute Value",
				"While creating a SingleNestedAttributeOneValue value, an extra attribute value was detected. "+
					"A SingleNestedAttributeOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedAttributeOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSingleNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedAttributeOneValueUnknown(), diags
	}

	return SingleNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedAttributeOneValue {
	object, diags := NewSingleNestedAttributeOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedAttributeOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedAttributeOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedAttributeOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedAttributeOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedAttributeOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedAttributeOneValueMust(SingleNestedAttributeOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedAttributeOneType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedAttributeOneValue{}
}

var _ basetypes.ObjectValuable = SingleNestedAttributeOneValue{}

type SingleNestedAttributeOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v SingleNestedAttributeOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedAttributeOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedAttributeOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedAttributeOneValue) String() string {
	return "SingleNestedAttributeOneValue"
}

func (v SingleNestedAttributeOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v SingleNestedAttributeOneValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedAttributeOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v SingleNestedAttributeOneValue) Type(ctx context.Context) attr.Type {
	return SingleNestedAttributeOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedAttributeOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SingleNestedAttributeThreeType{}

type SingleNestedAttributeThreeType struct {
	basetypes.ObjectType
}

func (t SingleNestedAttributeThreeType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedAttributeThreeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedAttributeThreeType) String() string {
	return "SingleNestedAttributeThreeType"
}

func (t SingleNestedAttributeThreeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	singleNestedAttributeThreeSingleNestedAttributeOneAttribute, ok := attributes["single_nested_attribute_three_single_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_attribute_three_single_nested_attribute_one is missing from object`)

		return nil, diags
	}

	singleNestedAttributeThreeSingleNestedAttributeOneVal, ok := singleNestedAttributeThreeSingleNestedAttributeOneAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_attribute_three_single_nested_attribute_one expected to be basetypes.ObjectValue, was: %T`, singleNestedAttributeThreeSingleNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedAttributeThreeValue{
		SingleNestedAttributeThreeSingleNestedAttributeOne: singleNestedAttributeThreeSingleNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeThreeValueNull() SingleNestedAttributeThreeValue {
	return SingleNestedAttributeThreeValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedAttributeThreeValueUnknown() SingleNestedAttributeThreeValue {
	return SingleNestedAttributeThreeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedAttributeThreeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedAttributeThreeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedAttributeThreeValue Attribute Value",
				"While creating a SingleNestedAttributeThreeValue value, a missing attribute value was detected. "+
					"A SingleNestedAttributeThreeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeThreeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedAttributeThreeValue Attribute Type",
				"While creating a SingleNestedAttributeThreeValue value, an invalid attribute value was detected. "+
					"A SingleNestedAttributeThreeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeThreeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedAttributeThreeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedAttributeThreeValue Attribute Value",
				"While creating a SingleNestedAttributeThreeValue value, an extra attribute value was detected. "+
					"A SingleNestedAttributeThreeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedAttributeThreeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedAttributeThreeValueUnknown(), diags
	}

	singleNestedAttributeThreeSingleNestedAttributeOneAttribute, ok := attributes["single_nested_attribute_three_single_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_attribute_three_single_nested_attribute_one is missing from object`)

		return NewSingleNestedAttributeThreeValueUnknown(), diags
	}

	singleNestedAttributeThreeSingleNestedAttributeOneVal, ok := singleNestedAttributeThreeSingleNestedAttributeOneAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_attribute_three_single_nested_attribute_one expected to be basetypes.ObjectValue, was: %T`, singleNestedAttributeThreeSingleNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedAttributeThreeValueUnknown(), diags
	}

	return SingleNestedAttributeThreeValue{
		SingleNestedAttributeThreeSingleNestedAttributeOne: singleNestedAttributeThreeSingleNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeThreeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedAttributeThreeValue {
	object, diags := NewSingleNestedAttributeThreeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedAttributeThreeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedAttributeThreeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedAttributeThreeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedAttributeThreeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedAttributeThreeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedAttributeThreeValueMust(SingleNestedAttributeThreeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedAttributeThreeType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedAttributeThreeValue{}
}

var _ basetypes.ObjectValuable = SingleNestedAttributeThreeValue{}

type SingleNestedAttributeThreeValue struct {
	SingleNestedAttributeThreeSingleNestedAttributeOne basetypes.ObjectValue `tfsdk:"single_nested_attribute_three_single_nested_attribute_one"`
	state                                              attr.ValueState
}

func (v SingleNestedAttributeThreeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["single_nested_attribute_three_single_nested_attribute_one"] = basetypes.ObjectType{
		AttrTypes: SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.SingleNestedAttributeThreeSingleNestedAttributeOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["single_nested_attribute_three_single_nested_attribute_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedAttributeThreeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedAttributeThreeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedAttributeThreeValue) String() string {
	return "SingleNestedAttributeThreeValue"
}

func (v SingleNestedAttributeThreeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var singleNestedAttributeThreeSingleNestedAttributeOne basetypes.ObjectValue

	if v.SingleNestedAttributeThreeSingleNestedAttributeOne.IsNull() {
		singleNestedAttributeThreeSingleNestedAttributeOne = types.ObjectNull(
			SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
		)
	}

	if v.SingleNestedAttributeThreeSingleNestedAttributeOne.IsUnknown() {
		singleNestedAttributeThreeSingleNestedAttributeOne = types.ObjectUnknown(
			SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SingleNestedAttributeThreeSingleNestedAttributeOne.IsNull() && !v.SingleNestedAttributeThreeSingleNestedAttributeOne.IsUnknown() {
		singleNestedAttributeThreeSingleNestedAttributeOne = types.ObjectValueMust(
			SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
			v.SingleNestedAttributeThreeSingleNestedAttributeOne.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"single_nested_attribute_three_single_nested_attribute_one": basetypes.ObjectType{
				AttrTypes: SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
			},
		},
		map[string]attr.Value{
			"single_nested_attribute_three_single_nested_attribute_one": singleNestedAttributeThreeSingleNestedAttributeOne,
		})

	return objVal, diags
}

func (v SingleNestedAttributeThreeValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedAttributeThreeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SingleNestedAttributeThreeSingleNestedAttributeOne.Equal(other.SingleNestedAttributeThreeSingleNestedAttributeOne) {
		return false
	}

	return true
}

func (v SingleNestedAttributeThreeValue) Type(ctx context.Context) attr.Type {
	return SingleNestedAttributeThreeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedAttributeThreeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"single_nested_attribute_three_single_nested_attribute_one": basetypes.ObjectType{
			AttrTypes: SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SingleNestedAttributeThreeSingleNestedAttributeOneType{}

type SingleNestedAttributeThreeSingleNestedAttributeOneType struct {
	basetypes.ObjectType
}

func (t SingleNestedAttributeThreeSingleNestedAttributeOneType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedAttributeThreeSingleNestedAttributeOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedAttributeThreeSingleNestedAttributeOneType) String() string {
	return "SingleNestedAttributeThreeSingleNestedAttributeOneType"
}

func (t SingleNestedAttributeThreeSingleNestedAttributeOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return nil, diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedAttributeThreeSingleNestedAttributeOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeThreeSingleNestedAttributeOneValueNull() SingleNestedAttributeThreeSingleNestedAttributeOneValue {
	return SingleNestedAttributeThreeSingleNestedAttributeOneValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedAttributeThreeSingleNestedAttributeOneValueUnknown() SingleNestedAttributeThreeSingleNestedAttributeOneValue {
	return SingleNestedAttributeThreeSingleNestedAttributeOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedAttributeThreeSingleNestedAttributeOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedAttributeThreeSingleNestedAttributeOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Value",
				"While creating a SingleNestedAttributeThreeSingleNestedAttributeOneValue value, a missing attribute value was detected. "+
					"A SingleNestedAttributeThreeSingleNestedAttributeOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Type",
				"While creating a SingleNestedAttributeThreeSingleNestedAttributeOneValue value, an invalid attribute value was detected. "+
					"A SingleNestedAttributeThreeSingleNestedAttributeOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Value",
				"While creating a SingleNestedAttributeThreeSingleNestedAttributeOneValue value, an extra attribute value was detected. "+
					"A SingleNestedAttributeThreeSingleNestedAttributeOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedAttributeThreeSingleNestedAttributeOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueUnknown(), diags
	}

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueUnknown(), diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueUnknown(), diags
	}

	return SingleNestedAttributeThreeSingleNestedAttributeOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeThreeSingleNestedAttributeOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedAttributeThreeSingleNestedAttributeOneValue {
	object, diags := NewSingleNestedAttributeThreeSingleNestedAttributeOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedAttributeThreeSingleNestedAttributeOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedAttributeThreeSingleNestedAttributeOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedAttributeThreeSingleNestedAttributeOneValueMust(SingleNestedAttributeThreeSingleNestedAttributeOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedAttributeThreeSingleNestedAttributeOneType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedAttributeThreeSingleNestedAttributeOneValue{}
}

var _ basetypes.ObjectValuable = SingleNestedAttributeThreeSingleNestedAttributeOneValue{}

type SingleNestedAttributeThreeSingleNestedAttributeOneValue struct {
	ListAttribute basetypes.ListValue `tfsdk:"list_attribute"`
	state         attr.ValueState
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_attribute"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) String() string {
	return "SingleNestedAttributeThreeSingleNestedAttributeOneValue"
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listAttributeVal, d := types.ListValue(types.StringType, v.ListAttribute.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"list_attribute": listAttributeVal,
		})

	return objVal, diags
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedAttributeThreeSingleNestedAttributeOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListAttribute.Equal(other.ListAttribute) {
		return false
	}

	return true
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) Type(ctx context.Context) attr.Type {
	return SingleNestedAttributeThreeSingleNestedAttributeOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedAttributeThreeSingleNestedAttributeOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_attribute": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SingleNestedAttributeTwoType{}

type SingleNestedAttributeTwoType struct {
	basetypes.ObjectType
}

func (t SingleNestedAttributeTwoType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedAttributeTwoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedAttributeTwoType) String() string {
	return "SingleNestedAttributeTwoType"
}

func (t SingleNestedAttributeTwoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	singleNestedAttributeTwoSingleNestedAttributeOneAttribute, ok := attributes["single_nested_attribute_two_single_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_attribute_two_single_nested_attribute_one is missing from object`)

		return nil, diags
	}

	singleNestedAttributeTwoSingleNestedAttributeOneVal, ok := singleNestedAttributeTwoSingleNestedAttributeOneAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_attribute_two_single_nested_attribute_one expected to be basetypes.ObjectValue, was: %T`, singleNestedAttributeTwoSingleNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedAttributeTwoValue{
		SingleNestedAttributeTwoSingleNestedAttributeOne: singleNestedAttributeTwoSingleNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeTwoValueNull() SingleNestedAttributeTwoValue {
	return SingleNestedAttributeTwoValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedAttributeTwoValueUnknown() SingleNestedAttributeTwoValue {
	return SingleNestedAttributeTwoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedAttributeTwoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedAttributeTwoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedAttributeTwoValue Attribute Value",
				"While creating a SingleNestedAttributeTwoValue value, a missing attribute value was detected. "+
					"A SingleNestedAttributeTwoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeTwoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedAttributeTwoValue Attribute Type",
				"While creating a SingleNestedAttributeTwoValue value, an invalid attribute value was detected. "+
					"A SingleNestedAttributeTwoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeTwoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedAttributeTwoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedAttributeTwoValue Attribute Value",
				"While creating a SingleNestedAttributeTwoValue value, an extra attribute value was detected. "+
					"A SingleNestedAttributeTwoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedAttributeTwoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedAttributeTwoValueUnknown(), diags
	}

	singleNestedAttributeTwoSingleNestedAttributeOneAttribute, ok := attributes["single_nested_attribute_two_single_nested_attribute_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_attribute_two_single_nested_attribute_one is missing from object`)

		return NewSingleNestedAttributeTwoValueUnknown(), diags
	}

	singleNestedAttributeTwoSingleNestedAttributeOneVal, ok := singleNestedAttributeTwoSingleNestedAttributeOneAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_attribute_two_single_nested_attribute_one expected to be basetypes.ObjectValue, was: %T`, singleNestedAttributeTwoSingleNestedAttributeOneAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedAttributeTwoValueUnknown(), diags
	}

	return SingleNestedAttributeTwoValue{
		SingleNestedAttributeTwoSingleNestedAttributeOne: singleNestedAttributeTwoSingleNestedAttributeOneVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeTwoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedAttributeTwoValue {
	object, diags := NewSingleNestedAttributeTwoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedAttributeTwoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedAttributeTwoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedAttributeTwoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedAttributeTwoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedAttributeTwoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedAttributeTwoValueMust(SingleNestedAttributeTwoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedAttributeTwoType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedAttributeTwoValue{}
}

var _ basetypes.ObjectValuable = SingleNestedAttributeTwoValue{}

type SingleNestedAttributeTwoValue struct {
	SingleNestedAttributeTwoSingleNestedAttributeOne basetypes.ObjectValue `tfsdk:"single_nested_attribute_two_single_nested_attribute_one"`
	state                                            attr.ValueState
}

func (v SingleNestedAttributeTwoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["single_nested_attribute_two_single_nested_attribute_one"] = basetypes.ObjectType{
		AttrTypes: SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.SingleNestedAttributeTwoSingleNestedAttributeOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["single_nested_attribute_two_single_nested_attribute_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedAttributeTwoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedAttributeTwoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedAttributeTwoValue) String() string {
	return "SingleNestedAttributeTwoValue"
}

func (v SingleNestedAttributeTwoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var singleNestedAttributeTwoSingleNestedAttributeOne basetypes.ObjectValue

	if v.SingleNestedAttributeTwoSingleNestedAttributeOne.IsNull() {
		singleNestedAttributeTwoSingleNestedAttributeOne = types.ObjectNull(
			SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
		)
	}

	if v.SingleNestedAttributeTwoSingleNestedAttributeOne.IsUnknown() {
		singleNestedAttributeTwoSingleNestedAttributeOne = types.ObjectUnknown(
			SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SingleNestedAttributeTwoSingleNestedAttributeOne.IsNull() && !v.SingleNestedAttributeTwoSingleNestedAttributeOne.IsUnknown() {
		singleNestedAttributeTwoSingleNestedAttributeOne = types.ObjectValueMust(
			SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
			v.SingleNestedAttributeTwoSingleNestedAttributeOne.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"single_nested_attribute_two_single_nested_attribute_one": basetypes.ObjectType{
				AttrTypes: SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
			},
		},
		map[string]attr.Value{
			"single_nested_attribute_two_single_nested_attribute_one": singleNestedAttributeTwoSingleNestedAttributeOne,
		})

	return objVal, diags
}

func (v SingleNestedAttributeTwoValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedAttributeTwoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SingleNestedAttributeTwoSingleNestedAttributeOne.Equal(other.SingleNestedAttributeTwoSingleNestedAttributeOne) {
		return false
	}

	return true
}

func (v SingleNestedAttributeTwoValue) Type(ctx context.Context) attr.Type {
	return SingleNestedAttributeTwoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedAttributeTwoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"single_nested_attribute_two_single_nested_attribute_one": basetypes.ObjectType{
			AttrTypes: SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SingleNestedAttributeTwoSingleNestedAttributeOneType{}

type SingleNestedAttributeTwoSingleNestedAttributeOneType struct {
	basetypes.ObjectType
}

func (t SingleNestedAttributeTwoSingleNestedAttributeOneType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedAttributeTwoSingleNestedAttributeOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedAttributeTwoSingleNestedAttributeOneType) String() string {
	return "SingleNestedAttributeTwoSingleNestedAttributeOneType"
}

func (t SingleNestedAttributeTwoSingleNestedAttributeOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedAttributeTwoSingleNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeTwoSingleNestedAttributeOneValueNull() SingleNestedAttributeTwoSingleNestedAttributeOneValue {
	return SingleNestedAttributeTwoSingleNestedAttributeOneValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedAttributeTwoSingleNestedAttributeOneValueUnknown() SingleNestedAttributeTwoSingleNestedAttributeOneValue {
	return SingleNestedAttributeTwoSingleNestedAttributeOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedAttributeTwoSingleNestedAttributeOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedAttributeTwoSingleNestedAttributeOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Value",
				"While creating a SingleNestedAttributeTwoSingleNestedAttributeOneValue value, a missing attribute value was detected. "+
					"A SingleNestedAttributeTwoSingleNestedAttributeOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Type",
				"While creating a SingleNestedAttributeTwoSingleNestedAttributeOneValue value, an invalid attribute value was detected. "+
					"A SingleNestedAttributeTwoSingleNestedAttributeOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Value",
				"While creating a SingleNestedAttributeTwoSingleNestedAttributeOneValue value, an extra attribute value was detected. "+
					"A SingleNestedAttributeTwoSingleNestedAttributeOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedAttributeTwoSingleNestedAttributeOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueUnknown(), diags
	}

	return SingleNestedAttributeTwoSingleNestedAttributeOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedAttributeTwoSingleNestedAttributeOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedAttributeTwoSingleNestedAttributeOneValue {
	object, diags := NewSingleNestedAttributeTwoSingleNestedAttributeOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedAttributeTwoSingleNestedAttributeOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedAttributeTwoSingleNestedAttributeOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedAttributeTwoSingleNestedAttributeOneValueMust(SingleNestedAttributeTwoSingleNestedAttributeOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedAttributeTwoSingleNestedAttributeOneType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedAttributeTwoSingleNestedAttributeOneValue{}
}

var _ basetypes.ObjectValuable = SingleNestedAttributeTwoSingleNestedAttributeOneValue{}

type SingleNestedAttributeTwoSingleNestedAttributeOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) String() string {
	return "SingleNestedAttributeTwoSingleNestedAttributeOneValue"
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedAttributeTwoSingleNestedAttributeOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) Type(ctx context.Context) attr.Type {
	return SingleNestedAttributeTwoSingleNestedAttributeOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedAttributeTwoSingleNestedAttributeOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ListNestedBlockAssocExtTypeType{}

type ListNestedBlockAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t ListNestedBlockAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedBlockAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedBlockAssocExtTypeType) String() string {
	return "ListNestedBlockAssocExtTypeType"
}

func (t ListNestedBlockAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedBlockAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockAssocExtTypeValueNull() ListNestedBlockAssocExtTypeValue {
	return ListNestedBlockAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedBlockAssocExtTypeValueUnknown() ListNestedBlockAssocExtTypeValue {
	return ListNestedBlockAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedBlockAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedBlockAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedBlockAssocExtTypeValue Attribute Value",
				"While creating a ListNestedBlockAssocExtTypeValue value, a missing attribute value was detected. "+
					"A ListNestedBlockAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedBlockAssocExtTypeValue Attribute Type",
				"While creating a ListNestedBlockAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A ListNestedBlockAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedBlockAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedBlockAssocExtTypeValue Attribute Value",
				"While creating a ListNestedBlockAssocExtTypeValue value, an extra attribute value was detected. "+
					"A ListNestedBlockAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedBlockAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedBlockAssocExtTypeValueUnknown(), diags
	}

	return ListNestedBlockAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedBlockAssocExtTypeValue {
	object, diags := NewListNestedBlockAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedBlockAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedBlockAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedBlockAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedBlockAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedBlockAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedBlockAssocExtTypeValueMust(ListNestedBlockAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedBlockAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return ListNestedBlockAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = ListNestedBlockAssocExtTypeValue{}

type ListNestedBlockAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v ListNestedBlockAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedBlockAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedBlockAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedBlockAssocExtTypeValue) String() string {
	return "ListNestedBlockAssocExtTypeValue"
}

func (v ListNestedBlockAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v ListNestedBlockAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedBlockAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v ListNestedBlockAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return ListNestedBlockAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedBlockAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ListNestedBlockOneType{}

type ListNestedBlockOneType struct {
	basetypes.ObjectType
}

func (t ListNestedBlockOneType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedBlockOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedBlockOneType) String() string {
	return "ListNestedBlockOneType"
}

func (t ListNestedBlockOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockOneValueNull() ListNestedBlockOneValue {
	return ListNestedBlockOneValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedBlockOneValueUnknown() ListNestedBlockOneValue {
	return ListNestedBlockOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedBlockOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedBlockOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedBlockOneValue Attribute Value",
				"While creating a ListNestedBlockOneValue value, a missing attribute value was detected. "+
					"A ListNestedBlockOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedBlockOneValue Attribute Type",
				"While creating a ListNestedBlockOneValue value, an invalid attribute value was detected. "+
					"A ListNestedBlockOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedBlockOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedBlockOneValue Attribute Value",
				"While creating a ListNestedBlockOneValue value, an extra attribute value was detected. "+
					"A ListNestedBlockOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedBlockOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedBlockOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewListNestedBlockOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedBlockOneValueUnknown(), diags
	}

	return ListNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedBlockOneValue {
	object, diags := NewListNestedBlockOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedBlockOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedBlockOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedBlockOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedBlockOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedBlockOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedBlockOneValueMust(ListNestedBlockOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedBlockOneType) ValueType(ctx context.Context) attr.Value {
	return ListNestedBlockOneValue{}
}

var _ basetypes.ObjectValuable = ListNestedBlockOneValue{}

type ListNestedBlockOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v ListNestedBlockOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedBlockOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedBlockOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedBlockOneValue) String() string {
	return "ListNestedBlockOneValue"
}

func (v ListNestedBlockOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v ListNestedBlockOneValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedBlockOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v ListNestedBlockOneValue) Type(ctx context.Context) attr.Type {
	return ListNestedBlockOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedBlockOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ListNestedBlockThreeType{}

type ListNestedBlockThreeType struct {
	basetypes.ObjectType
}

func (t ListNestedBlockThreeType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedBlockThreeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedBlockThreeType) String() string {
	return "ListNestedBlockThreeType"
}

func (t ListNestedBlockThreeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listNestedBlockThreeListNestedBlockOneAttribute, ok := attributes["list_nested_block_three_list_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_block_three_list_nested_block_one is missing from object`)

		return nil, diags
	}

	listNestedBlockThreeListNestedBlockOneVal, ok := listNestedBlockThreeListNestedBlockOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_block_three_list_nested_block_one expected to be basetypes.ListValue, was: %T`, listNestedBlockThreeListNestedBlockOneAttribute))
	}

	objectAttributeAttribute, ok := attributes["object_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_attribute is missing from object`)

		return nil, diags
	}

	objectAttributeVal, ok := objectAttributeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_attribute expected to be basetypes.ObjectValue, was: %T`, objectAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedBlockThreeValue{
		ListNestedBlockThreeListNestedBlockOne: listNestedBlockThreeListNestedBlockOneVal,
		ObjectAttribute:                        objectAttributeVal,
		state:                                  attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockThreeValueNull() ListNestedBlockThreeValue {
	return ListNestedBlockThreeValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedBlockThreeValueUnknown() ListNestedBlockThreeValue {
	return ListNestedBlockThreeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedBlockThreeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedBlockThreeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedBlockThreeValue Attribute Value",
				"While creating a ListNestedBlockThreeValue value, a missing attribute value was detected. "+
					"A ListNestedBlockThreeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockThreeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedBlockThreeValue Attribute Type",
				"While creating a ListNestedBlockThreeValue value, an invalid attribute value was detected. "+
					"A ListNestedBlockThreeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockThreeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedBlockThreeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedBlockThreeValue Attribute Value",
				"While creating a ListNestedBlockThreeValue value, an extra attribute value was detected. "+
					"A ListNestedBlockThreeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedBlockThreeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedBlockThreeValueUnknown(), diags
	}

	listNestedBlockThreeListNestedBlockOneAttribute, ok := attributes["list_nested_block_three_list_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_block_three_list_nested_block_one is missing from object`)

		return NewListNestedBlockThreeValueUnknown(), diags
	}

	listNestedBlockThreeListNestedBlockOneVal, ok := listNestedBlockThreeListNestedBlockOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_block_three_list_nested_block_one expected to be basetypes.ListValue, was: %T`, listNestedBlockThreeListNestedBlockOneAttribute))
	}

	objectAttributeAttribute, ok := attributes["object_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_attribute is missing from object`)

		return NewListNestedBlockThreeValueUnknown(), diags
	}

	objectAttributeVal, ok := objectAttributeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_attribute expected to be basetypes.ObjectValue, was: %T`, objectAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedBlockThreeValueUnknown(), diags
	}

	return ListNestedBlockThreeValue{
		ListNestedBlockThreeListNestedBlockOne: listNestedBlockThreeListNestedBlockOneVal,
		ObjectAttribute:                        objectAttributeVal,
		state:                                  attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockThreeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedBlockThreeValue {
	object, diags := NewListNestedBlockThreeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedBlockThreeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedBlockThreeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedBlockThreeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedBlockThreeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedBlockThreeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedBlockThreeValueMust(ListNestedBlockThreeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedBlockThreeType) ValueType(ctx context.Context) attr.Value {
	return ListNestedBlockThreeValue{}
}

var _ basetypes.ObjectValuable = ListNestedBlockThreeValue{}

type ListNestedBlockThreeValue struct {
	ListNestedBlockThreeListNestedBlockOne basetypes.ListValue   `tfsdk:"list_nested_block_three_list_nested_block_one"`
	ObjectAttribute                        basetypes.ObjectValue `tfsdk:"object_attribute"`
	state                                  attr.ValueState
}

func (v ListNestedBlockThreeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["list_nested_block_three_list_nested_block_one"] = basetypes.ListType{
		ElemType: ListNestedBlockThreeListNestedBlockOneValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["object_attribute"] = basetypes.ObjectType{
		AttrTypes: map[string]attr.Type{
			"string_attribute_type": types.StringType,
		},
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ListNestedBlockThreeListNestedBlockOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_nested_block_three_list_nested_block_one"] = val

		val, err = v.ObjectAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["object_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedBlockThreeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedBlockThreeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedBlockThreeValue) String() string {
	return "ListNestedBlockThreeValue"
}

func (v ListNestedBlockThreeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listNestedBlockThreeListNestedBlockOne := types.ListValueMust(
		ListNestedBlockThreeListNestedBlockOneType{
			basetypes.ObjectType{
				AttrTypes: ListNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
			},
		},
		v.ListNestedBlockThreeListNestedBlockOne.Elements(),
	)

	if v.ListNestedBlockThreeListNestedBlockOne.IsNull() {
		listNestedBlockThreeListNestedBlockOne = types.ListNull(
			ListNestedBlockThreeListNestedBlockOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ListNestedBlockThreeListNestedBlockOne.IsUnknown() {
		listNestedBlockThreeListNestedBlockOne = types.ListUnknown(
			ListNestedBlockThreeListNestedBlockOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objectAttributeVal, d := types.ObjectValue(v.ObjectAttribute.AttributeTypes(ctx), v.ObjectAttribute.Attributes())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"list_nested_block_three_list_nested_block_one": basetypes.ObjectType{
				AttrTypes: v.ObjectAttribute.AttributeTypes(ctx),
			},
			"object_attribute": basetypes.ObjectType{
				AttrTypes: v.ObjectAttribute.AttributeTypes(ctx),
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_nested_block_three_list_nested_block_one": basetypes.ListType{
				ElemType: ListNestedBlockThreeListNestedBlockOneValue{}.Type(ctx),
			},
			"object_attribute": basetypes.ObjectType{
				AttrTypes: v.ObjectAttribute.AttributeTypes(ctx),
			},
		},
		map[string]attr.Value{
			"list_nested_block_three_list_nested_block_one": listNestedBlockThreeListNestedBlockOne,
			"object_attribute": objectAttributeVal,
		})

	return objVal, diags
}

func (v ListNestedBlockThreeValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedBlockThreeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListNestedBlockThreeListNestedBlockOne.Equal(other.ListNestedBlockThreeListNestedBlockOne) {
		return false
	}

	if !v.ObjectAttribute.Equal(other.ObjectAttribute) {
		return false
	}

	return true
}

func (v ListNestedBlockThreeValue) Type(ctx context.Context) attr.Type {
	return ListNestedBlockThreeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedBlockThreeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_nested_block_three_list_nested_block_one": basetypes.ListType{
			ElemType: ListNestedBlockThreeListNestedBlockOneValue{}.Type(ctx),
		},
		"object_attribute": basetypes.ObjectType{
			AttrTypes: map[string]attr.Type{
				"string_attribute_type": types.StringType,
			},
		},
	}
}

var _ basetypes.ObjectTypable = ListNestedBlockThreeListNestedBlockOneType{}

type ListNestedBlockThreeListNestedBlockOneType struct {
	basetypes.ObjectType
}

func (t ListNestedBlockThreeListNestedBlockOneType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedBlockThreeListNestedBlockOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedBlockThreeListNestedBlockOneType) String() string {
	return "ListNestedBlockThreeListNestedBlockOneType"
}

func (t ListNestedBlockThreeListNestedBlockOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return nil, diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedBlockThreeListNestedBlockOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockThreeListNestedBlockOneValueNull() ListNestedBlockThreeListNestedBlockOneValue {
	return ListNestedBlockThreeListNestedBlockOneValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedBlockThreeListNestedBlockOneValueUnknown() ListNestedBlockThreeListNestedBlockOneValue {
	return ListNestedBlockThreeListNestedBlockOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedBlockThreeListNestedBlockOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedBlockThreeListNestedBlockOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedBlockThreeListNestedBlockOneValue Attribute Value",
				"While creating a ListNestedBlockThreeListNestedBlockOneValue value, a missing attribute value was detected. "+
					"A ListNestedBlockThreeListNestedBlockOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockThreeListNestedBlockOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedBlockThreeListNestedBlockOneValue Attribute Type",
				"While creating a ListNestedBlockThreeListNestedBlockOneValue value, an invalid attribute value was detected. "+
					"A ListNestedBlockThreeListNestedBlockOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockThreeListNestedBlockOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedBlockThreeListNestedBlockOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedBlockThreeListNestedBlockOneValue Attribute Value",
				"While creating a ListNestedBlockThreeListNestedBlockOneValue value, an extra attribute value was detected. "+
					"A ListNestedBlockThreeListNestedBlockOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedBlockThreeListNestedBlockOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedBlockThreeListNestedBlockOneValueUnknown(), diags
	}

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return NewListNestedBlockThreeListNestedBlockOneValueUnknown(), diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedBlockThreeListNestedBlockOneValueUnknown(), diags
	}

	return ListNestedBlockThreeListNestedBlockOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockThreeListNestedBlockOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedBlockThreeListNestedBlockOneValue {
	object, diags := NewListNestedBlockThreeListNestedBlockOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedBlockThreeListNestedBlockOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedBlockThreeListNestedBlockOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedBlockThreeListNestedBlockOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedBlockThreeListNestedBlockOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedBlockThreeListNestedBlockOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedBlockThreeListNestedBlockOneValueMust(ListNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedBlockThreeListNestedBlockOneType) ValueType(ctx context.Context) attr.Value {
	return ListNestedBlockThreeListNestedBlockOneValue{}
}

var _ basetypes.ObjectValuable = ListNestedBlockThreeListNestedBlockOneValue{}

type ListNestedBlockThreeListNestedBlockOneValue struct {
	ListAttribute basetypes.ListValue `tfsdk:"list_attribute"`
	state         attr.ValueState
}

func (v ListNestedBlockThreeListNestedBlockOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_attribute"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedBlockThreeListNestedBlockOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedBlockThreeListNestedBlockOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedBlockThreeListNestedBlockOneValue) String() string {
	return "ListNestedBlockThreeListNestedBlockOneValue"
}

func (v ListNestedBlockThreeListNestedBlockOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listAttributeVal, d := types.ListValue(types.StringType, v.ListAttribute.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"list_attribute": listAttributeVal,
		})

	return objVal, diags
}

func (v ListNestedBlockThreeListNestedBlockOneValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedBlockThreeListNestedBlockOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListAttribute.Equal(other.ListAttribute) {
		return false
	}

	return true
}

func (v ListNestedBlockThreeListNestedBlockOneValue) Type(ctx context.Context) attr.Type {
	return ListNestedBlockThreeListNestedBlockOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedBlockThreeListNestedBlockOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_attribute": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ListNestedBlockTwoType{}

type ListNestedBlockTwoType struct {
	basetypes.ObjectType
}

func (t ListNestedBlockTwoType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedBlockTwoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedBlockTwoType) String() string {
	return "ListNestedBlockTwoType"
}

func (t ListNestedBlockTwoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listNestedBlockTwoListNestedBlockOneAttribute, ok := attributes["list_nested_block_two_list_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_block_two_list_nested_block_one is missing from object`)

		return nil, diags
	}

	listNestedBlockTwoListNestedBlockOneVal, ok := listNestedBlockTwoListNestedBlockOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_block_two_list_nested_block_one expected to be basetypes.ListValue, was: %T`, listNestedBlockTwoListNestedBlockOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedBlockTwoValue{
		ListNestedBlockTwoListNestedBlockOne: listNestedBlockTwoListNestedBlockOneVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockTwoValueNull() ListNestedBlockTwoValue {
	return ListNestedBlockTwoValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedBlockTwoValueUnknown() ListNestedBlockTwoValue {
	return ListNestedBlockTwoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedBlockTwoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedBlockTwoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedBlockTwoValue Attribute Value",
				"While creating a ListNestedBlockTwoValue value, a missing attribute value was detected. "+
					"A ListNestedBlockTwoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockTwoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedBlockTwoValue Attribute Type",
				"While creating a ListNestedBlockTwoValue value, an invalid attribute value was detected. "+
					"A ListNestedBlockTwoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockTwoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedBlockTwoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedBlockTwoValue Attribute Value",
				"While creating a ListNestedBlockTwoValue value, an extra attribute value was detected. "+
					"A ListNestedBlockTwoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedBlockTwoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedBlockTwoValueUnknown(), diags
	}

	listNestedBlockTwoListNestedBlockOneAttribute, ok := attributes["list_nested_block_two_list_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_nested_block_two_list_nested_block_one is missing from object`)

		return NewListNestedBlockTwoValueUnknown(), diags
	}

	listNestedBlockTwoListNestedBlockOneVal, ok := listNestedBlockTwoListNestedBlockOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_nested_block_two_list_nested_block_one expected to be basetypes.ListValue, was: %T`, listNestedBlockTwoListNestedBlockOneAttribute))
	}

	if diags.HasError() {
		return NewListNestedBlockTwoValueUnknown(), diags
	}

	return ListNestedBlockTwoValue{
		ListNestedBlockTwoListNestedBlockOne: listNestedBlockTwoListNestedBlockOneVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockTwoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedBlockTwoValue {
	object, diags := NewListNestedBlockTwoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedBlockTwoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedBlockTwoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedBlockTwoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedBlockTwoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedBlockTwoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedBlockTwoValueMust(ListNestedBlockTwoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedBlockTwoType) ValueType(ctx context.Context) attr.Value {
	return ListNestedBlockTwoValue{}
}

var _ basetypes.ObjectValuable = ListNestedBlockTwoValue{}

type ListNestedBlockTwoValue struct {
	ListNestedBlockTwoListNestedBlockOne basetypes.ListValue `tfsdk:"list_nested_block_two_list_nested_block_one"`
	state                                attr.ValueState
}

func (v ListNestedBlockTwoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_nested_block_two_list_nested_block_one"] = basetypes.ListType{
		ElemType: ListNestedBlockTwoListNestedBlockOneValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListNestedBlockTwoListNestedBlockOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_nested_block_two_list_nested_block_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedBlockTwoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedBlockTwoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedBlockTwoValue) String() string {
	return "ListNestedBlockTwoValue"
}

func (v ListNestedBlockTwoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listNestedBlockTwoListNestedBlockOne := types.ListValueMust(
		ListNestedBlockTwoListNestedBlockOneType{
			basetypes.ObjectType{
				AttrTypes: ListNestedBlockTwoListNestedBlockOneValue{}.AttributeTypes(ctx),
			},
		},
		v.ListNestedBlockTwoListNestedBlockOne.Elements(),
	)

	if v.ListNestedBlockTwoListNestedBlockOne.IsNull() {
		listNestedBlockTwoListNestedBlockOne = types.ListNull(
			ListNestedBlockTwoListNestedBlockOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedBlockTwoListNestedBlockOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ListNestedBlockTwoListNestedBlockOne.IsUnknown() {
		listNestedBlockTwoListNestedBlockOne = types.ListUnknown(
			ListNestedBlockTwoListNestedBlockOneType{
				basetypes.ObjectType{
					AttrTypes: ListNestedBlockTwoListNestedBlockOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_nested_block_two_list_nested_block_one": basetypes.ListType{
				ElemType: ListNestedBlockTwoListNestedBlockOneValue{}.Type(ctx),
			},
		},
		map[string]attr.Value{
			"list_nested_block_two_list_nested_block_one": listNestedBlockTwoListNestedBlockOne,
		})

	return objVal, diags
}

func (v ListNestedBlockTwoValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedBlockTwoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListNestedBlockTwoListNestedBlockOne.Equal(other.ListNestedBlockTwoListNestedBlockOne) {
		return false
	}

	return true
}

func (v ListNestedBlockTwoValue) Type(ctx context.Context) attr.Type {
	return ListNestedBlockTwoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedBlockTwoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_nested_block_two_list_nested_block_one": basetypes.ListType{
			ElemType: ListNestedBlockTwoListNestedBlockOneValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ListNestedBlockTwoListNestedBlockOneType{}

type ListNestedBlockTwoListNestedBlockOneType struct {
	basetypes.ObjectType
}

func (t ListNestedBlockTwoListNestedBlockOneType) Equal(o attr.Type) bool {
	other, ok := o.(ListNestedBlockTwoListNestedBlockOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ListNestedBlockTwoListNestedBlockOneType) String() string {
	return "ListNestedBlockTwoListNestedBlockOneType"
}

func (t ListNestedBlockTwoListNestedBlockOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ListNestedBlockTwoListNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockTwoListNestedBlockOneValueNull() ListNestedBlockTwoListNestedBlockOneValue {
	return ListNestedBlockTwoListNestedBlockOneValue{
		state: attr.ValueStateNull,
	}
}

func NewListNestedBlockTwoListNestedBlockOneValueUnknown() ListNestedBlockTwoListNestedBlockOneValue {
	return ListNestedBlockTwoListNestedBlockOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewListNestedBlockTwoListNestedBlockOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ListNestedBlockTwoListNestedBlockOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ListNestedBlockTwoListNestedBlockOneValue Attribute Value",
				"While creating a ListNestedBlockTwoListNestedBlockOneValue value, a missing attribute value was detected. "+
					"A ListNestedBlockTwoListNestedBlockOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockTwoListNestedBlockOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ListNestedBlockTwoListNestedBlockOneValue Attribute Type",
				"While creating a ListNestedBlockTwoListNestedBlockOneValue value, an invalid attribute value was detected. "+
					"A ListNestedBlockTwoListNestedBlockOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ListNestedBlockTwoListNestedBlockOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ListNestedBlockTwoListNestedBlockOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ListNestedBlockTwoListNestedBlockOneValue Attribute Value",
				"While creating a ListNestedBlockTwoListNestedBlockOneValue value, an extra attribute value was detected. "+
					"A ListNestedBlockTwoListNestedBlockOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ListNestedBlockTwoListNestedBlockOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewListNestedBlockTwoListNestedBlockOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewListNestedBlockTwoListNestedBlockOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewListNestedBlockTwoListNestedBlockOneValueUnknown(), diags
	}

	return ListNestedBlockTwoListNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewListNestedBlockTwoListNestedBlockOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ListNestedBlockTwoListNestedBlockOneValue {
	object, diags := NewListNestedBlockTwoListNestedBlockOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewListNestedBlockTwoListNestedBlockOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ListNestedBlockTwoListNestedBlockOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewListNestedBlockTwoListNestedBlockOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewListNestedBlockTwoListNestedBlockOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewListNestedBlockTwoListNestedBlockOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewListNestedBlockTwoListNestedBlockOneValueMust(ListNestedBlockTwoListNestedBlockOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ListNestedBlockTwoListNestedBlockOneType) ValueType(ctx context.Context) attr.Value {
	return ListNestedBlockTwoListNestedBlockOneValue{}
}

var _ basetypes.ObjectValuable = ListNestedBlockTwoListNestedBlockOneValue{}

type ListNestedBlockTwoListNestedBlockOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v ListNestedBlockTwoListNestedBlockOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ListNestedBlockTwoListNestedBlockOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ListNestedBlockTwoListNestedBlockOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ListNestedBlockTwoListNestedBlockOneValue) String() string {
	return "ListNestedBlockTwoListNestedBlockOneValue"
}

func (v ListNestedBlockTwoListNestedBlockOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v ListNestedBlockTwoListNestedBlockOneValue) Equal(o attr.Value) bool {
	other, ok := o.(ListNestedBlockTwoListNestedBlockOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v ListNestedBlockTwoListNestedBlockOneValue) Type(ctx context.Context) attr.Type {
	return ListNestedBlockTwoListNestedBlockOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ListNestedBlockTwoListNestedBlockOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SetNestedBlockAssocExtTypeType{}

type SetNestedBlockAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t SetNestedBlockAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(SetNestedBlockAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SetNestedBlockAssocExtTypeType) String() string {
	return "SetNestedBlockAssocExtTypeType"
}

func (t SetNestedBlockAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SetNestedBlockAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSetNestedBlockAssocExtTypeValueNull() SetNestedBlockAssocExtTypeValue {
	return SetNestedBlockAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewSetNestedBlockAssocExtTypeValueUnknown() SetNestedBlockAssocExtTypeValue {
	return SetNestedBlockAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSetNestedBlockAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SetNestedBlockAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SetNestedBlockAssocExtTypeValue Attribute Value",
				"While creating a SetNestedBlockAssocExtTypeValue value, a missing attribute value was detected. "+
					"A SetNestedBlockAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SetNestedBlockAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SetNestedBlockAssocExtTypeValue Attribute Type",
				"While creating a SetNestedBlockAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A SetNestedBlockAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SetNestedBlockAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SetNestedBlockAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SetNestedBlockAssocExtTypeValue Attribute Value",
				"While creating a SetNestedBlockAssocExtTypeValue value, an extra attribute value was detected. "+
					"A SetNestedBlockAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SetNestedBlockAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewSetNestedBlockAssocExtTypeValueUnknown(), diags
	}

	return SetNestedBlockAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSetNestedBlockAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SetNestedBlockAssocExtTypeValue {
	object, diags := NewSetNestedBlockAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSetNestedBlockAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SetNestedBlockAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSetNestedBlockAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSetNestedBlockAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSetNestedBlockAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSetNestedBlockAssocExtTypeValueMust(SetNestedBlockAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SetNestedBlockAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return SetNestedBlockAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = SetNestedBlockAssocExtTypeValue{}

type SetNestedBlockAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v SetNestedBlockAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SetNestedBlockAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SetNestedBlockAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SetNestedBlockAssocExtTypeValue) String() string {
	return "SetNestedBlockAssocExtTypeValue"
}

func (v SetNestedBlockAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v SetNestedBlockAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(SetNestedBlockAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v SetNestedBlockAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return SetNestedBlockAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SetNestedBlockAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SingleNestedBlockAssocExtTypeType{}

type SingleNestedBlockAssocExtTypeType struct {
	basetypes.ObjectType
}

func (t SingleNestedBlockAssocExtTypeType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedBlockAssocExtTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedBlockAssocExtTypeType) String() string {
	return "SingleNestedBlockAssocExtTypeType"
}

func (t SingleNestedBlockAssocExtTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return nil, diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return nil, diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return nil, diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return nil, diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedBlockAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockAssocExtTypeValueNull() SingleNestedBlockAssocExtTypeValue {
	return SingleNestedBlockAssocExtTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedBlockAssocExtTypeValueUnknown() SingleNestedBlockAssocExtTypeValue {
	return SingleNestedBlockAssocExtTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedBlockAssocExtTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedBlockAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedBlockAssocExtTypeValue Attribute Value",
				"While creating a SingleNestedBlockAssocExtTypeValue value, a missing attribute value was detected. "+
					"A SingleNestedBlockAssocExtTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockAssocExtTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedBlockAssocExtTypeValue Attribute Type",
				"While creating a SingleNestedBlockAssocExtTypeValue value, an invalid attribute value was detected. "+
					"A SingleNestedBlockAssocExtTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockAssocExtTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedBlockAssocExtTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedBlockAssocExtTypeValue Attribute Value",
				"While creating a SingleNestedBlockAssocExtTypeValue value, an extra attribute value was detected. "+
					"A SingleNestedBlockAssocExtTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedBlockAssocExtTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	float64AttributeAttribute, ok := attributes["float64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`float64_attribute is missing from object`)

		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	float64AttributeVal, ok := float64AttributeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`float64_attribute expected to be basetypes.Float64Value, was: %T`, float64AttributeAttribute))
	}

	int64AttributeAttribute, ok := attributes["int64_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`int64_attribute is missing from object`)

		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	int64AttributeVal, ok := int64AttributeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`int64_attribute expected to be basetypes.Int64Value, was: %T`, int64AttributeAttribute))
	}

	numberAttributeAttribute, ok := attributes["number_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number_attribute is missing from object`)

		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	numberAttributeVal, ok := numberAttributeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number_attribute expected to be basetypes.NumberValue, was: %T`, numberAttributeAttribute))
	}

	stringAttributeAttribute, ok := attributes["string_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`string_attribute is missing from object`)

		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	stringAttributeVal, ok := stringAttributeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`string_attribute expected to be basetypes.StringValue, was: %T`, stringAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedBlockAssocExtTypeValueUnknown(), diags
	}

	return SingleNestedBlockAssocExtTypeValue{
		BoolAttribute:    boolAttributeVal,
		Float64Attribute: float64AttributeVal,
		Int64Attribute:   int64AttributeVal,
		NumberAttribute:  numberAttributeVal,
		StringAttribute:  stringAttributeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockAssocExtTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedBlockAssocExtTypeValue {
	object, diags := NewSingleNestedBlockAssocExtTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedBlockAssocExtTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedBlockAssocExtTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedBlockAssocExtTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedBlockAssocExtTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedBlockAssocExtTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedBlockAssocExtTypeValueMust(SingleNestedBlockAssocExtTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedBlockAssocExtTypeType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedBlockAssocExtTypeValue{}
}

var _ basetypes.ObjectValuable = SingleNestedBlockAssocExtTypeValue{}

type SingleNestedBlockAssocExtTypeValue struct {
	BoolAttribute    basetypes.BoolValue    `tfsdk:"bool_attribute"`
	Float64Attribute basetypes.Float64Value `tfsdk:"float64_attribute"`
	Int64Attribute   basetypes.Int64Value   `tfsdk:"int64_attribute"`
	NumberAttribute  basetypes.NumberValue  `tfsdk:"number_attribute"`
	StringAttribute  basetypes.StringValue  `tfsdk:"string_attribute"`
	state            attr.ValueState
}

func (v SingleNestedBlockAssocExtTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["float64_attribute"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["int64_attribute"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number_attribute"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["string_attribute"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		val, err = v.Float64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["float64_attribute"] = val

		val, err = v.Int64Attribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["int64_attribute"] = val

		val, err = v.NumberAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number_attribute"] = val

		val, err = v.StringAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["string_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedBlockAssocExtTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedBlockAssocExtTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedBlockAssocExtTypeValue) String() string {
	return "SingleNestedBlockAssocExtTypeValue"
}

func (v SingleNestedBlockAssocExtTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute":    basetypes.BoolType{},
			"float64_attribute": basetypes.Float64Type{},
			"int64_attribute":   basetypes.Int64Type{},
			"number_attribute":  basetypes.NumberType{},
			"string_attribute":  basetypes.StringType{},
		},
		map[string]attr.Value{
			"bool_attribute":    v.BoolAttribute,
			"float64_attribute": v.Float64Attribute,
			"int64_attribute":   v.Int64Attribute,
			"number_attribute":  v.NumberAttribute,
			"string_attribute":  v.StringAttribute,
		})

	return objVal, diags
}

func (v SingleNestedBlockAssocExtTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedBlockAssocExtTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	if !v.Float64Attribute.Equal(other.Float64Attribute) {
		return false
	}

	if !v.Int64Attribute.Equal(other.Int64Attribute) {
		return false
	}

	if !v.NumberAttribute.Equal(other.NumberAttribute) {
		return false
	}

	if !v.StringAttribute.Equal(other.StringAttribute) {
		return false
	}

	return true
}

func (v SingleNestedBlockAssocExtTypeValue) Type(ctx context.Context) attr.Type {
	return SingleNestedBlockAssocExtTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedBlockAssocExtTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute":    basetypes.BoolType{},
		"float64_attribute": basetypes.Float64Type{},
		"int64_attribute":   basetypes.Int64Type{},
		"number_attribute":  basetypes.NumberType{},
		"string_attribute":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SingleNestedBlockOneType{}

type SingleNestedBlockOneType struct {
	basetypes.ObjectType
}

func (t SingleNestedBlockOneType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedBlockOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedBlockOneType) String() string {
	return "SingleNestedBlockOneType"
}

func (t SingleNestedBlockOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockOneValueNull() SingleNestedBlockOneValue {
	return SingleNestedBlockOneValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedBlockOneValueUnknown() SingleNestedBlockOneValue {
	return SingleNestedBlockOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedBlockOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedBlockOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedBlockOneValue Attribute Value",
				"While creating a SingleNestedBlockOneValue value, a missing attribute value was detected. "+
					"A SingleNestedBlockOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedBlockOneValue Attribute Type",
				"While creating a SingleNestedBlockOneValue value, an invalid attribute value was detected. "+
					"A SingleNestedBlockOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedBlockOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedBlockOneValue Attribute Value",
				"While creating a SingleNestedBlockOneValue value, an extra attribute value was detected. "+
					"A SingleNestedBlockOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedBlockOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedBlockOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSingleNestedBlockOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedBlockOneValueUnknown(), diags
	}

	return SingleNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedBlockOneValue {
	object, diags := NewSingleNestedBlockOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedBlockOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedBlockOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedBlockOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedBlockOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedBlockOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedBlockOneValueMust(SingleNestedBlockOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedBlockOneType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedBlockOneValue{}
}

var _ basetypes.ObjectValuable = SingleNestedBlockOneValue{}

type SingleNestedBlockOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v SingleNestedBlockOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedBlockOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedBlockOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedBlockOneValue) String() string {
	return "SingleNestedBlockOneValue"
}

func (v SingleNestedBlockOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v SingleNestedBlockOneValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedBlockOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v SingleNestedBlockOneValue) Type(ctx context.Context) attr.Type {
	return SingleNestedBlockOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedBlockOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SingleNestedBlockThreeType{}

type SingleNestedBlockThreeType struct {
	basetypes.ObjectType
}

func (t SingleNestedBlockThreeType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedBlockThreeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedBlockThreeType) String() string {
	return "SingleNestedBlockThreeType"
}

func (t SingleNestedBlockThreeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	objectAttributeAttribute, ok := attributes["object_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_attribute is missing from object`)

		return nil, diags
	}

	objectAttributeVal, ok := objectAttributeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_attribute expected to be basetypes.ObjectValue, was: %T`, objectAttributeAttribute))
	}

	singleNestedBlockThreeListNestedBlockOneAttribute, ok := attributes["single_nested_block_three_list_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_block_three_list_nested_block_one is missing from object`)

		return nil, diags
	}

	singleNestedBlockThreeListNestedBlockOneVal, ok := singleNestedBlockThreeListNestedBlockOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_block_three_list_nested_block_one expected to be basetypes.ListValue, was: %T`, singleNestedBlockThreeListNestedBlockOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedBlockThreeValue{
		ObjectAttribute:                          objectAttributeVal,
		SingleNestedBlockThreeListNestedBlockOne: singleNestedBlockThreeListNestedBlockOneVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockThreeValueNull() SingleNestedBlockThreeValue {
	return SingleNestedBlockThreeValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedBlockThreeValueUnknown() SingleNestedBlockThreeValue {
	return SingleNestedBlockThreeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedBlockThreeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedBlockThreeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedBlockThreeValue Attribute Value",
				"While creating a SingleNestedBlockThreeValue value, a missing attribute value was detected. "+
					"A SingleNestedBlockThreeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockThreeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedBlockThreeValue Attribute Type",
				"While creating a SingleNestedBlockThreeValue value, an invalid attribute value was detected. "+
					"A SingleNestedBlockThreeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockThreeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedBlockThreeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedBlockThreeValue Attribute Value",
				"While creating a SingleNestedBlockThreeValue value, an extra attribute value was detected. "+
					"A SingleNestedBlockThreeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedBlockThreeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedBlockThreeValueUnknown(), diags
	}

	objectAttributeAttribute, ok := attributes["object_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`object_attribute is missing from object`)

		return NewSingleNestedBlockThreeValueUnknown(), diags
	}

	objectAttributeVal, ok := objectAttributeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`object_attribute expected to be basetypes.ObjectValue, was: %T`, objectAttributeAttribute))
	}

	singleNestedBlockThreeListNestedBlockOneAttribute, ok := attributes["single_nested_block_three_list_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_block_three_list_nested_block_one is missing from object`)

		return NewSingleNestedBlockThreeValueUnknown(), diags
	}

	singleNestedBlockThreeListNestedBlockOneVal, ok := singleNestedBlockThreeListNestedBlockOneAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_block_three_list_nested_block_one expected to be basetypes.ListValue, was: %T`, singleNestedBlockThreeListNestedBlockOneAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedBlockThreeValueUnknown(), diags
	}

	return SingleNestedBlockThreeValue{
		ObjectAttribute:                          objectAttributeVal,
		SingleNestedBlockThreeListNestedBlockOne: singleNestedBlockThreeListNestedBlockOneVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockThreeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedBlockThreeValue {
	object, diags := NewSingleNestedBlockThreeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedBlockThreeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedBlockThreeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedBlockThreeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedBlockThreeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedBlockThreeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedBlockThreeValueMust(SingleNestedBlockThreeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedBlockThreeType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedBlockThreeValue{}
}

var _ basetypes.ObjectValuable = SingleNestedBlockThreeValue{}

type SingleNestedBlockThreeValue struct {
	ObjectAttribute                          basetypes.ObjectValue `tfsdk:"object_attribute"`
	SingleNestedBlockThreeListNestedBlockOne basetypes.ListValue   `tfsdk:"single_nested_block_three_list_nested_block_one"`
	state                                    attr.ValueState
}

func (v SingleNestedBlockThreeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["object_attribute"] = basetypes.ObjectType{
		AttrTypes: map[string]attr.Type{
			"string_attribute_type": types.StringType,
		},
	}.TerraformType(ctx)
	attrTypes["single_nested_block_three_list_nested_block_one"] = basetypes.ListType{
		ElemType: SingleNestedBlockThreeListNestedBlockOneValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ObjectAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["object_attribute"] = val

		val, err = v.SingleNestedBlockThreeListNestedBlockOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["single_nested_block_three_list_nested_block_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedBlockThreeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedBlockThreeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedBlockThreeValue) String() string {
	return "SingleNestedBlockThreeValue"
}

func (v SingleNestedBlockThreeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	singleNestedBlockThreeListNestedBlockOne := types.ListValueMust(
		SingleNestedBlockThreeListNestedBlockOneType{
			basetypes.ObjectType{
				AttrTypes: SingleNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
			},
		},
		v.SingleNestedBlockThreeListNestedBlockOne.Elements(),
	)

	if v.SingleNestedBlockThreeListNestedBlockOne.IsNull() {
		singleNestedBlockThreeListNestedBlockOne = types.ListNull(
			SingleNestedBlockThreeListNestedBlockOneType{
				basetypes.ObjectType{
					AttrTypes: SingleNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SingleNestedBlockThreeListNestedBlockOne.IsUnknown() {
		singleNestedBlockThreeListNestedBlockOne = types.ListUnknown(
			SingleNestedBlockThreeListNestedBlockOneType{
				basetypes.ObjectType{
					AttrTypes: SingleNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objectAttributeVal, d := types.ObjectValue(v.ObjectAttribute.AttributeTypes(ctx), v.ObjectAttribute.Attributes())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"object_attribute": basetypes.ObjectType{
				AttrTypes: v.ObjectAttribute.AttributeTypes(ctx),
			},
			"single_nested_block_three_list_nested_block_one": basetypes.ObjectType{
				AttrTypes: v.ObjectAttribute.AttributeTypes(ctx),
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"object_attribute": basetypes.ObjectType{
				AttrTypes: v.ObjectAttribute.AttributeTypes(ctx),
			},
			"single_nested_block_three_list_nested_block_one": basetypes.ListType{
				ElemType: SingleNestedBlockThreeListNestedBlockOneValue{}.Type(ctx),
			},
		},
		map[string]attr.Value{
			"object_attribute": objectAttributeVal,
			"single_nested_block_three_list_nested_block_one": singleNestedBlockThreeListNestedBlockOne,
		})

	return objVal, diags
}

func (v SingleNestedBlockThreeValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedBlockThreeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ObjectAttribute.Equal(other.ObjectAttribute) {
		return false
	}

	if !v.SingleNestedBlockThreeListNestedBlockOne.Equal(other.SingleNestedBlockThreeListNestedBlockOne) {
		return false
	}

	return true
}

func (v SingleNestedBlockThreeValue) Type(ctx context.Context) attr.Type {
	return SingleNestedBlockThreeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedBlockThreeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"object_attribute": basetypes.ObjectType{
			AttrTypes: map[string]attr.Type{
				"string_attribute_type": types.StringType,
			},
		},
		"single_nested_block_three_list_nested_block_one": basetypes.ListType{
			ElemType: SingleNestedBlockThreeListNestedBlockOneValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SingleNestedBlockThreeListNestedBlockOneType{}

type SingleNestedBlockThreeListNestedBlockOneType struct {
	basetypes.ObjectType
}

func (t SingleNestedBlockThreeListNestedBlockOneType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedBlockThreeListNestedBlockOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedBlockThreeListNestedBlockOneType) String() string {
	return "SingleNestedBlockThreeListNestedBlockOneType"
}

func (t SingleNestedBlockThreeListNestedBlockOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return nil, diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedBlockThreeListNestedBlockOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockThreeListNestedBlockOneValueNull() SingleNestedBlockThreeListNestedBlockOneValue {
	return SingleNestedBlockThreeListNestedBlockOneValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedBlockThreeListNestedBlockOneValueUnknown() SingleNestedBlockThreeListNestedBlockOneValue {
	return SingleNestedBlockThreeListNestedBlockOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedBlockThreeListNestedBlockOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedBlockThreeListNestedBlockOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedBlockThreeListNestedBlockOneValue Attribute Value",
				"While creating a SingleNestedBlockThreeListNestedBlockOneValue value, a missing attribute value was detected. "+
					"A SingleNestedBlockThreeListNestedBlockOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockThreeListNestedBlockOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedBlockThreeListNestedBlockOneValue Attribute Type",
				"While creating a SingleNestedBlockThreeListNestedBlockOneValue value, an invalid attribute value was detected. "+
					"A SingleNestedBlockThreeListNestedBlockOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockThreeListNestedBlockOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedBlockThreeListNestedBlockOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedBlockThreeListNestedBlockOneValue Attribute Value",
				"While creating a SingleNestedBlockThreeListNestedBlockOneValue value, an extra attribute value was detected. "+
					"A SingleNestedBlockThreeListNestedBlockOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedBlockThreeListNestedBlockOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedBlockThreeListNestedBlockOneValueUnknown(), diags
	}

	listAttributeAttribute, ok := attributes["list_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`list_attribute is missing from object`)

		return NewSingleNestedBlockThreeListNestedBlockOneValueUnknown(), diags
	}

	listAttributeVal, ok := listAttributeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`list_attribute expected to be basetypes.ListValue, was: %T`, listAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedBlockThreeListNestedBlockOneValueUnknown(), diags
	}

	return SingleNestedBlockThreeListNestedBlockOneValue{
		ListAttribute: listAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockThreeListNestedBlockOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedBlockThreeListNestedBlockOneValue {
	object, diags := NewSingleNestedBlockThreeListNestedBlockOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedBlockThreeListNestedBlockOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedBlockThreeListNestedBlockOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedBlockThreeListNestedBlockOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedBlockThreeListNestedBlockOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedBlockThreeListNestedBlockOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedBlockThreeListNestedBlockOneValueMust(SingleNestedBlockThreeListNestedBlockOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedBlockThreeListNestedBlockOneType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedBlockThreeListNestedBlockOneValue{}
}

var _ basetypes.ObjectValuable = SingleNestedBlockThreeListNestedBlockOneValue{}

type SingleNestedBlockThreeListNestedBlockOneValue struct {
	ListAttribute basetypes.ListValue `tfsdk:"list_attribute"`
	state         attr.ValueState
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["list_attribute"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ListAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["list_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) String() string {
	return "SingleNestedBlockThreeListNestedBlockOneValue"
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	listAttributeVal, d := types.ListValue(types.StringType, v.ListAttribute.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"list_attribute": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"list_attribute": listAttributeVal,
		})

	return objVal, diags
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedBlockThreeListNestedBlockOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ListAttribute.Equal(other.ListAttribute) {
		return false
	}

	return true
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) Type(ctx context.Context) attr.Type {
	return SingleNestedBlockThreeListNestedBlockOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedBlockThreeListNestedBlockOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"list_attribute": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SingleNestedBlockTwoType{}

type SingleNestedBlockTwoType struct {
	basetypes.ObjectType
}

func (t SingleNestedBlockTwoType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedBlockTwoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedBlockTwoType) String() string {
	return "SingleNestedBlockTwoType"
}

func (t SingleNestedBlockTwoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	singleNestedBlockTwoSingleNestedBlockOneAttribute, ok := attributes["single_nested_block_two_single_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_block_two_single_nested_block_one is missing from object`)

		return nil, diags
	}

	singleNestedBlockTwoSingleNestedBlockOneVal, ok := singleNestedBlockTwoSingleNestedBlockOneAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_block_two_single_nested_block_one expected to be basetypes.ObjectValue, was: %T`, singleNestedBlockTwoSingleNestedBlockOneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedBlockTwoValue{
		SingleNestedBlockTwoSingleNestedBlockOne: singleNestedBlockTwoSingleNestedBlockOneVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockTwoValueNull() SingleNestedBlockTwoValue {
	return SingleNestedBlockTwoValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedBlockTwoValueUnknown() SingleNestedBlockTwoValue {
	return SingleNestedBlockTwoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedBlockTwoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedBlockTwoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedBlockTwoValue Attribute Value",
				"While creating a SingleNestedBlockTwoValue value, a missing attribute value was detected. "+
					"A SingleNestedBlockTwoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockTwoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedBlockTwoValue Attribute Type",
				"While creating a SingleNestedBlockTwoValue value, an invalid attribute value was detected. "+
					"A SingleNestedBlockTwoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockTwoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedBlockTwoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedBlockTwoValue Attribute Value",
				"While creating a SingleNestedBlockTwoValue value, an extra attribute value was detected. "+
					"A SingleNestedBlockTwoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedBlockTwoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedBlockTwoValueUnknown(), diags
	}

	singleNestedBlockTwoSingleNestedBlockOneAttribute, ok := attributes["single_nested_block_two_single_nested_block_one"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`single_nested_block_two_single_nested_block_one is missing from object`)

		return NewSingleNestedBlockTwoValueUnknown(), diags
	}

	singleNestedBlockTwoSingleNestedBlockOneVal, ok := singleNestedBlockTwoSingleNestedBlockOneAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`single_nested_block_two_single_nested_block_one expected to be basetypes.ObjectValue, was: %T`, singleNestedBlockTwoSingleNestedBlockOneAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedBlockTwoValueUnknown(), diags
	}

	return SingleNestedBlockTwoValue{
		SingleNestedBlockTwoSingleNestedBlockOne: singleNestedBlockTwoSingleNestedBlockOneVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockTwoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedBlockTwoValue {
	object, diags := NewSingleNestedBlockTwoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedBlockTwoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedBlockTwoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedBlockTwoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedBlockTwoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedBlockTwoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedBlockTwoValueMust(SingleNestedBlockTwoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedBlockTwoType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedBlockTwoValue{}
}

var _ basetypes.ObjectValuable = SingleNestedBlockTwoValue{}

type SingleNestedBlockTwoValue struct {
	SingleNestedBlockTwoSingleNestedBlockOne basetypes.ObjectValue `tfsdk:"single_nested_block_two_single_nested_block_one"`
	state                                    attr.ValueState
}

func (v SingleNestedBlockTwoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["single_nested_block_two_single_nested_block_one"] = basetypes.ObjectType{
		AttrTypes: SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.SingleNestedBlockTwoSingleNestedBlockOne.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["single_nested_block_two_single_nested_block_one"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedBlockTwoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedBlockTwoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedBlockTwoValue) String() string {
	return "SingleNestedBlockTwoValue"
}

func (v SingleNestedBlockTwoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var singleNestedBlockTwoSingleNestedBlockOne basetypes.ObjectValue

	if v.SingleNestedBlockTwoSingleNestedBlockOne.IsNull() {
		singleNestedBlockTwoSingleNestedBlockOne = types.ObjectNull(
			SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
		)
	}

	if v.SingleNestedBlockTwoSingleNestedBlockOne.IsUnknown() {
		singleNestedBlockTwoSingleNestedBlockOne = types.ObjectUnknown(
			SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SingleNestedBlockTwoSingleNestedBlockOne.IsNull() && !v.SingleNestedBlockTwoSingleNestedBlockOne.IsUnknown() {
		singleNestedBlockTwoSingleNestedBlockOne = types.ObjectValueMust(
			SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
			v.SingleNestedBlockTwoSingleNestedBlockOne.Attributes(),
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"single_nested_block_two_single_nested_block_one": basetypes.ObjectType{
				AttrTypes: SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
			},
		},
		map[string]attr.Value{
			"single_nested_block_two_single_nested_block_one": singleNestedBlockTwoSingleNestedBlockOne,
		})

	return objVal, diags
}

func (v SingleNestedBlockTwoValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedBlockTwoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SingleNestedBlockTwoSingleNestedBlockOne.Equal(other.SingleNestedBlockTwoSingleNestedBlockOne) {
		return false
	}

	return true
}

func (v SingleNestedBlockTwoValue) Type(ctx context.Context) attr.Type {
	return SingleNestedBlockTwoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedBlockTwoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"single_nested_block_two_single_nested_block_one": basetypes.ObjectType{
			AttrTypes: SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SingleNestedBlockTwoSingleNestedBlockOneType{}

type SingleNestedBlockTwoSingleNestedBlockOneType struct {
	basetypes.ObjectType
}

func (t SingleNestedBlockTwoSingleNestedBlockOneType) Equal(o attr.Type) bool {
	other, ok := o.(SingleNestedBlockTwoSingleNestedBlockOneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SingleNestedBlockTwoSingleNestedBlockOneType) String() string {
	return "SingleNestedBlockTwoSingleNestedBlockOneType"
}

func (t SingleNestedBlockTwoSingleNestedBlockOneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return nil, diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SingleNestedBlockTwoSingleNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockTwoSingleNestedBlockOneValueNull() SingleNestedBlockTwoSingleNestedBlockOneValue {
	return SingleNestedBlockTwoSingleNestedBlockOneValue{
		state: attr.ValueStateNull,
	}
}

func NewSingleNestedBlockTwoSingleNestedBlockOneValueUnknown() SingleNestedBlockTwoSingleNestedBlockOneValue {
	return SingleNestedBlockTwoSingleNestedBlockOneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSingleNestedBlockTwoSingleNestedBlockOneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SingleNestedBlockTwoSingleNestedBlockOneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Value",
				"While creating a SingleNestedBlockTwoSingleNestedBlockOneValue value, a missing attribute value was detected. "+
					"A SingleNestedBlockTwoSingleNestedBlockOneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Type",
				"While creating a SingleNestedBlockTwoSingleNestedBlockOneValue value, an invalid attribute value was detected. "+
					"A SingleNestedBlockTwoSingleNestedBlockOneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Value",
				"While creating a SingleNestedBlockTwoSingleNestedBlockOneValue value, an extra attribute value was detected. "+
					"A SingleNestedBlockTwoSingleNestedBlockOneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SingleNestedBlockTwoSingleNestedBlockOneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSingleNestedBlockTwoSingleNestedBlockOneValueUnknown(), diags
	}

	boolAttributeAttribute, ok := attributes["bool_attribute"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bool_attribute is missing from object`)

		return NewSingleNestedBlockTwoSingleNestedBlockOneValueUnknown(), diags
	}

	boolAttributeVal, ok := boolAttributeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bool_attribute expected to be basetypes.BoolValue, was: %T`, boolAttributeAttribute))
	}

	if diags.HasError() {
		return NewSingleNestedBlockTwoSingleNestedBlockOneValueUnknown(), diags
	}

	return SingleNestedBlockTwoSingleNestedBlockOneValue{
		BoolAttribute: boolAttributeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSingleNestedBlockTwoSingleNestedBlockOneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SingleNestedBlockTwoSingleNestedBlockOneValue {
	object, diags := NewSingleNestedBlockTwoSingleNestedBlockOneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSingleNestedBlockTwoSingleNestedBlockOneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SingleNestedBlockTwoSingleNestedBlockOneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSingleNestedBlockTwoSingleNestedBlockOneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSingleNestedBlockTwoSingleNestedBlockOneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSingleNestedBlockTwoSingleNestedBlockOneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSingleNestedBlockTwoSingleNestedBlockOneValueMust(SingleNestedBlockTwoSingleNestedBlockOneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SingleNestedBlockTwoSingleNestedBlockOneType) ValueType(ctx context.Context) attr.Value {
	return SingleNestedBlockTwoSingleNestedBlockOneValue{}
}

var _ basetypes.ObjectValuable = SingleNestedBlockTwoSingleNestedBlockOneValue{}

type SingleNestedBlockTwoSingleNestedBlockOneValue struct {
	BoolAttribute basetypes.BoolValue `tfsdk:"bool_attribute"`
	state         attr.ValueState
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bool_attribute"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BoolAttribute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bool_attribute"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) String() string {
	return "SingleNestedBlockTwoSingleNestedBlockOneValue"
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"bool_attribute": basetypes.BoolType{},
		},
		map[string]attr.Value{
			"bool_attribute": v.BoolAttribute,
		})

	return objVal, diags
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) Equal(o attr.Value) bool {
	other, ok := o.(SingleNestedBlockTwoSingleNestedBlockOneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoolAttribute.Equal(other.BoolAttribute) {
		return false
	}

	return true
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) Type(ctx context.Context) attr.Type {
	return SingleNestedBlockTwoSingleNestedBlockOneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SingleNestedBlockTwoSingleNestedBlockOneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bool_attribute": basetypes.BoolType{},
	}
}

func (v ListNestedAttributeAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"ListNestedAttributeAssocExtTypeValue Value Is Unknown",
			`"ListNestedAttributeAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v ListNestedAttributeAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (ListNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewListNestedAttributeAssocExtTypeValueNull(), diags
	}

	return ListNestedAttributeAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}

func (v MapNestedAttributeAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"MapNestedAttributeAssocExtTypeValue Value Is Unknown",
			`"MapNestedAttributeAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v MapNestedAttributeAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (MapNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewMapNestedAttributeAssocExtTypeValueNull(), diags
	}

	return MapNestedAttributeAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}

func (v SetNestedAttributeAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"SetNestedAttributeAssocExtTypeValue Value Is Unknown",
			`"SetNestedAttributeAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v SetNestedAttributeAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (SetNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewSetNestedAttributeAssocExtTypeValueNull(), diags
	}

	return SetNestedAttributeAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}

func (v SingleNestedAttributeAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"SingleNestedAttributeAssocExtTypeValue Value Is Unknown",
			`"SingleNestedAttributeAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v SingleNestedAttributeAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (SingleNestedAttributeAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewSingleNestedAttributeAssocExtTypeValueNull(), diags
	}

	return SingleNestedAttributeAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}

func (v ListNestedBlockAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"ListNestedBlockAssocExtTypeValue Value Is Unknown",
			`"ListNestedBlockAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v ListNestedBlockAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (ListNestedBlockAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewListNestedBlockAssocExtTypeValueNull(), diags
	}

	return ListNestedBlockAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}

func (v SetNestedBlockAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"SetNestedBlockAssocExtTypeValue Value Is Unknown",
			`"SetNestedBlockAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v SetNestedBlockAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (SetNestedBlockAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewSetNestedBlockAssocExtTypeValueNull(), diags
	}

	return SetNestedBlockAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}

func (v SingleNestedBlockAssocExtTypeValue) ToApisdkType(ctx context.Context) (*apisdk.Type, diag.Diagnostics) {
	var diags diag.Diagnostics

	if v.IsNull() {
		return nil, diags
	}

	if v.IsUnknown() {
		diags.Append(diag.NewErrorDiagnostic(
			"SingleNestedBlockAssocExtTypeValue Value Is Unknown",
			`"SingleNestedBlockAssocExtTypeValue" is unknown.`,
		))

		return nil, diags
	}

	return &apisdk.Type{
		BoolAttribute:    v.BoolAttribute.ValueBoolPointer(),
		Float64Attribute: v.Float64Attribute.ValueFloat64Pointer(),
		Int64Attribute:   v.Int64Attribute.ValueInt64Pointer(),
		NumberAttribute:  v.NumberAttribute.ValueBigFloat(),
		StringAttribute:  v.StringAttribute.ValueStringPointer(),
	}, diags
}

func (v SingleNestedBlockAssocExtTypeValue) FromApisdkType(ctx context.Context, apiObject *apisdk.Type) (SingleNestedBlockAssocExtTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	if apiObject == nil {
		return NewSingleNestedBlockAssocExtTypeValueNull(), diags
	}

	return SingleNestedBlockAssocExtTypeValue{
		BoolAttribute:    types.BoolPointerValue(apiObject.BoolAttribute),
		Float64Attribute: types.Float64PointerValue(apiObject.Float64Attribute),
		Int64Attribute:   types.Int64PointerValue(apiObject.Int64Attribute),
		NumberAttribute:  types.NumberValue(apiObject.NumberAttribute),
		StringAttribute:  types.StringPointerValue(apiObject.StringAttribute),
		state:            attr.ValueStateKnown,
	}, diags
}
